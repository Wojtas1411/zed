---
title: "Report"
author: "Me"
date: "Today"
knit: (function(input_file, encoding) {
  out_dir <- 'html';
  rmarkdown::render(input_file, encoding=encoding, output_file=file.path(dirname(input_file), out_dir, 'index.html'))
 })


output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, message=FALSE}
library(readxl)
library(httr)
library(arules)
library(tidyr)
library(dplyr)
library(lubridate)
library(stringr)
```
# Przetwarzanie zbioru danych
## Odczyt danych
Odczyt danych przeprowdzony jest bezośrednio ze strony, aby zapewenić stałą wartość początkową dla każdego uruchomienia.
Dodatkowo uzupełniane są brakujące dane identyfikatory pacjentów ```PATIENT_ID```. Wartości brakujące wynikają ze sposobu przetwarzania scalonych komórek pliku źródłowego.
```{r read-data, message=FALSE, results='hide'}
# https://stackoverflow.com/a/41368947
url <- "http://www.cs.put.poznan.pl/dbrzezinski/teaching/zed/wuhan_blood_sample_data_Jan_Feb_2020.xlsx"
GET(url, write_disk(tf <- tempfile(fileext = ".xlsx")))
df <- read_excel(tf) %>% fill(PATIENT_ID)
```

## Atrybuty zbioru danych
Surowy zbiór danych zawiera `r ncol(df)` atrybutów i `r nrow(df)` wierszy.  

### Atrybuty ogólne
Pierwszych siedem kolumn to atrybuty ogólne, reprezentują następująco:
  
* PATEINT_ID - sztuczny identyfikator pacjenta
* RE_DATE - najpewniej jest to data wprowadzenia wyniku badań próbki krwi do systemu
* age - wiek pacjenta
* gender - płeć pacjenta, przyjmuje wartość 1 albo 2, ale z poisu zbioru danych nie wynika wprost, które oznaczenie jest przypisane do której płci
* Admission time - czas przyjęcia pacjenta do szpitala
* Discharge time - czas zakończenia leczenia (w skutek wypisu pacjenta lub jego śmierci)
* outcome - rezultat, przyjmuje wartość 0 jeżeli pacjent został wyleczony, lub wartość 1 jeżeli zmarł.

Nazwy wyżej wymienionych atrybutów zostaną przeformatowane, będą pisane wielkimi literami, a ewentualne spacje będą zamieniane na znak podkreślinka `_`, w ten sposób atrbuty ogólne będą łatwo odróżnialne od pozostałych atrybutów.

```{r rename top 7 columns}
df <- df %>% rename_with(~ toupper(gsub(" ", "_", .x, fixed = TRUE)), 1:7)
```

Pola `GENDER` i `OUTCOME` zostaną dodatkowo zmienione na typ `factor` - z typu numerycznego zamienione zostaną na zmienne nominalne.
Do tego trzeba przeprowadzić identyfikację typu płci.

Wartości płci nie są jawnie opisane, w artykule źródłowym została natomiast podana proporcja pacjentów danej płci, co powinno umożliwić okreslenie właściwego przypisania.
```{r}
knitr::kable(
table(df %>% group_by(PATIENT_ID) %>% summarise_all(last) %>% select(GENDER)),
col.names = c("GENDER", "count")
)
```

Wniosek:  c
* Mężczyźni - wartość `1`
* Kobiety - wartość `2`

```{r factorize}
df <- df %>% mutate(across("GENDER", ~factor(., levels=c(1,2), labels=c("MALE", "FEMALE")))) %>%
  mutate(across("OUTCOME", ~factor(., levels=c(0,1), labels=c("CURED","DECEASED"))))
```

Poniżej można zapoznać się z analizą wartości dla atrybutów ogólnych.
Wartość atrybutu `RE_DATE` ma unikalną wartość dla kazdego wiersza.

```{r re_date summary}
knitr::kable(summary(select(df, RE_DATE)))
```
Pozostałe z atrybtów ogólnych, są wspólne dla każdego pacjenta, zastosowano transformację do zniwelowania skutków duplikacji.

```{r top summary}
knitr::kable(summary(df %>% select(c(1,3:7)) %>% group_by(PATIENT_ID) %>% summarise_all(last) ))
```
Dodatkowo, dla pewności wyznaczamy liczbę pacjentów.

```{r patients count init}
length(unique(df$PATIENT_ID))
```

TODO opis

```{r}
knitr::kable(
df %>% select(1:7) %>% select(-RE_DATE) %>% 
  group_by(PATIENT_ID) %>% summarise_all(last) %>% ungroup() %>% 
  mutate(HOSPITALIZATION_TIME = difftime(ceiling_date(DISCHARGE_TIME, "1 day"), floor_date(ADMISSION_TIME, "1 day"), unit="days")) %>%
  select(-PATIENT_ID, -ADMISSION_TIME, -DISCHARGE_TIME) %>% group_by(OUTCOME, GENDER) %>% 
  summarise_all(median)
)
```


TODO osobna analiza outcome vs wiek

### Usuwanie wierszy, które nie zawierają danych z badań

W powyższej tabeli zauważono wystąpienia wartości brakującyc dla kolumny `RE_DATE`. 
Szybkie sprawdzenie wykazuje, że dla wierszy, gdzie nie ma atrybut `RE_DATE` przyjmuje wartość 'NA', wartości wszystkich atrybutów pochodzących z badań krwi, równiez przyjmują wartość 'NA'.
```{r empty rows check}
all(sapply(df[is.na(df$RE_DATE), -c(1,3:7)], is.na))
```

```{r}
knitr::kable(
df %>% filter(is.na(RE_DATE)) %>% group_by(PATIENT_ID) %>% summarise_all(last) %>%
  mutate(HOSPITALIZATION_TIME = difftime(ceiling_date(DISCHARGE_TIME, "1 day"), floor_date(ADMISSION_TIME, "1 day"), unit="days")) %>%
  select(OUTCOME, HOSPITALIZATION_TIME) %>%
  summarise(HOSPITALIZATION_TIME = quantile(HOSPITALIZATION_TIME, c(0, 0.25, 0.5, 0.75,1)), quantile = c("min", "1st", "2nd", "3rd", "max"))
)
```

Co jest podstawą do usunięcia tych wierszy ze zbioru danych.

```{r clear-empty}
df = df[!is.na(df$RE_DATE),]
```

Po tej zmianie w zbiorze pozostało `{r} nrow(df)` wierszy.

Co istotne, 14 usuniętych wierszy, opdpowiada takiej samej ilości usuniętych pacjentów.
```{r patients count}
length(unique(df$PATIENT_ID))
```
TODO komentarz do usunięcia

### Stworzenie dodatkowej cechy

TODO days to outcome
TODO days from admission

### Wyniki badań
Pozostałe `r ncol(df)-7` kolumn zawiera wartości atrybutów, które reprezentują rodzaje miar zebranych podczas każdego badania.

Nazwy kolumn zostały poddane następującym transformacjom:

* TODO

```{r renaming attributes names}
df <- df %>%
  rename("NT-proBNP" = "Amino-terminal brain natriuretic peptide precursor(NT-proBNP)") %>%
  rename_with(~str_c(str_replace(.x, "\\(%\\)", ""), "_percent"), contains("(%)")) %>%
  rename_with(~str_replace(.x, "\\(#\\)", "")) %>%
  rename_with(tolower, matches("^[[:upper:]]{1}[[:lower:]]+", ignore.case = FALSE)) %>%
  rename_with(~str_replace_all(.x, "[ |-]", "_"))
str_sort(colnames(df[,-(1:7)]))
```

Wstępnę analiza danych sugeruje wskazuje, że wiele wartości atrybutów jest oznaczona wartością 'NA'.
W poniższych blokach kodu, wyliczana jest liczba elementów, które mają wartość inną niż 'NA' dla każdego wiersza.

```{r historam of number of not NA values per row}
row.counts <- rowSums(sapply(df[,-(1:7)], function(x) !is.na(x)))
summary(row.counts)
```

```{r hist 1, echo=FALSE}
hist(row.counts, breaks=(ncol(df)-7))
```
TODO analiza i wnioski

* prawie połowa rekordów ma zaledwie jeden wynik badania.
* co ciekawe, druga i trzecia pod względem liczości grupa rekordów ma odpowiednio po 24 i 23 elementy.
* Można dokonać analizy, czy te grupy powstają losowo, czy mają jakiś wspólny podzbiór -> analiza zbiorów częstych.


## Zbiory częste badań
Zauważamy, że dużo NA, wynika to z tego, że badania są rozrzucone.
Badanie zbiorów, czy któreś są częstsze niż inne.
```{r transactions}
transactions <- sapply(df[,-(1:7)], function(x) !is.na(x))
```

Ilość unikalnych transakcji
```{r unique transactions count}
length(unique(apply(transactions, 1, function(x) which(x))))
```

Szukamy maksymalnych domkniętych zbiorów częstych - sprawdzamy czy badania występują w grupach.

```{r apriori}
itemsets <- apriori(transactions, parameter = list(target="closed frequent itemsets", support=.05, minlen=1, maxlen=30, maxtime=60))
mc_itemsets <- itemsets[is.maximal(itemsets)]
inspect(head(sort(mc_itemsets, by = 'support'), 10))
```

TODO wnioski ze zbiorów częstych


Wyniki różnych testów prawdopodobnie pojawiały się w systemie o różnych porach, dlatego można je razem agregować.

### Grupowanie wyników badań

TODO Analiza ilości badań przeprowadzonych jednemu pacjentowi. 
```{r group by patient id}
gb.patient_id <- df %>% group_by(PATIENT_ID) %>% fill(everything()) %>% summarise_all(last)
rc.gb.patient_id <- rowSums(sapply(gb.patient_id[,-(1:7)], function(x) !is.na(x)))
hist(rc.gb.patient_id, breaks=(ncol(gb.patient_id)-7))

```



```{r group by patient id summary}
summary(rc.gb.patient_id)
```



```{r number of missing values in each column}
knitr::kable(
sort(colSums(sapply(gb.patient_id[,-(1:7)], is.na)))
)
```

```{r g2}
g2 <- df %>% mutate(RE_DATE = floor_date(RE_DATE, '1 day')) %>% group_by(PATIENT_ID, RE_DATE) %>% fill(everything()) %>% summarise_all(last) %>% ungroup()
row.counts.g2 <- rowSums(sapply(g2[,-(1:7)], function(x) !is.na(x)))
hist(row.counts.g2, breaks=(ncol(g2)-7))
```

