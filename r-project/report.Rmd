---
title: "Report"
author: "Me"
date: "Today"
knit: (function(input_file, encoding) {
  out_dir <- 'html';
  rmarkdown::render(input_file, encoding=encoding, output_file=file.path(dirname(input_file), out_dir, 'index.html'))
 })


output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, message=FALSE, echo=FALSE}
library(readxl)
library(httr)
library(arules)
library(tidyr)
library(dplyr)
library(lubridate)
library(stringr)
library(ggplot2)
```

# Przetwarzanie zbioru danych
## Odczyt danych
Odczyt danych przeprowdzony jest bezośrednio ze strony, aby zapewenić stałą wartość początkową dla każdego uruchomienia.
Dodatkowo uzupełniane są brakujące dane identyfikatory pacjentów ```PATIENT_ID```. Wartości brakujące wynikają ze sposobu przetwarzania scalonych komórek pliku źródłowego.
```{r read-data, message=FALSE, results='hide'}
# https://stackoverflow.com/a/41368947
url <- "http://www.cs.put.poznan.pl/dbrzezinski/teaching/zed/wuhan_blood_sample_data_Jan_Feb_2020.xlsx"
GET(url, write_disk(tf <- tempfile(fileext = ".xlsx")))
df <- read_excel(tf) %>% fill(PATIENT_ID)
```

## Atrybuty zbioru danych
Surowy zbiór danych zawiera `r ncol(df)` atrybutów i `r nrow(df)` wierszy.  

TODO opisać podział na atrybuty ogólne i wyniki badań

### Atrybuty ogólne
Pierwszych siedem kolumn to atrybuty ogólne, reprezentują następująco:
  
* PATEINT_ID - sztuczny identyfikator pacjenta
* RE_DATE - najpewniej jest to data wprowadzenia wyniku badań próbki krwi do systemu
* age - wiek pacjenta
* gender - płeć pacjenta, przyjmuje wartość 1 albo 2, ale z poisu zbioru danych nie wynika wprost, które oznaczenie jest przypisane do której płci
* Admission time - czas przyjęcia pacjenta do szpitala
* Discharge time - czas zakończenia leczenia (w skutek wypisu pacjenta lub jego śmierci)
* outcome - rezultat, przyjmuje wartość 0 jeżeli pacjent został wyleczony, lub wartość 1 jeżeli zmarł.

Nazwy wyżej wymienionych atrybutów zostaną przeformatowane, będą pisane wielkimi literami, a ewentualne spacje będą zamieniane na znak podkreślinka `_`, w ten sposób atrbuty ogólne będą łatwo odróżnialne od pozostałych atrybutów.

```{r rename top 7 columns}
df <- df %>% rename_with(~ toupper(gsub(" ", "_", .x, fixed = TRUE)), 1:7)
```

Pola `GENDER` i `OUTCOME` zostaną dodatkowo zmienione na typ `factor` - z typu numerycznego zamienione zostaną na zmienne nominalne.
Do tego trzeba przeprowadzić identyfikację typu płci.

Wartości płci nie są jawnie opisane, w artykule źródłowym została natomiast podana proporcja pacjentów danej płci, co powinno umożliwić okreslenie właściwego przypisania.
```{r}
knitr::kable(
table(df %>% group_by(PATIENT_ID) %>% summarise_all(last) %>% select(GENDER)),
col.names = c("GENDER", "count")
)
```

Wniosek:  
* Mężczyźni - wartość `1`
* Kobiety - wartość `2`

```{r factorize}
df <- df %>% mutate(across("GENDER", ~factor(., levels=c(1,2), labels=c("MALE", "FEMALE")))) %>%
  mutate(across("OUTCOME", ~factor(., levels=c(0,1), labels=c("CURED","DECEASED"))))
```

Poniżej można zapoznać się z analizą wartości dla atrybutów ogólnych.
Wartość atrybutu `RE_DATE` ma unikalną wartość dla kazdego wiersza.

```{r re_date summary}
knitr::kable(summary(select(df, RE_DATE)))
```
Pozostałe z atrybtów ogólnych, są wspólne dla każdego pacjenta, zastosowano transformację do zniwelowania skutków duplikacji.

```{r top summary}
knitr::kable(
  summary(
    df %>% 
      select(c(1,3:7)) %>% 
      group_by(PATIENT_ID) %>% 
      summarise_all(last)
    )
  )
```
Liczba unikatowych identyfikatorów pacjentów wynosi `r length(unique(df$PATIENT_ID))`.

### Czas hosptializacji

Ta sekcja poświęcona jest analizie długości hospitalizacji poszczególnych grup pacjentów.

```{r, echo=FALSE}
hospitalization_times <- df %>% select(1:7) %>% select(-RE_DATE) %>% 
  group_by(PATIENT_ID) %>% summarise_all(last) %>% ungroup() %>% 
  mutate(HOSPITALIZATION_TIME = difftime(ceiling_date(DISCHARGE_TIME, "1 day"), floor_date(ADMISSION_TIME, "1 day"), unit="days"))

knitr::kable(
hospitalization_times %>% 
  summarise(HOSPITALIZATION_TIME = quantile(HOSPITALIZATION_TIME, c(0, 0.25, 0.5, 0.75,1)), quantile = c("min", "1st", "2nd", "3rd", "max"))
)
```

```{r, echo=FALSE}
hist(
  sapply(hospitalization_times$HOSPITALIZATION_TIME, function(x) as.numeric(x, units="days")),
  breaks=36, xlab="Hospitalization period [days]", main="Hitogram of Hospitalization period [days]")
```

```{r, echo=FALSE}
knitr::kable(
hospitalization_times %>%
  select(-PATIENT_ID, -ADMISSION_TIME, -DISCHARGE_TIME) %>% group_by(OUTCOME, GENDER) %>% 
  summarise_all(median)
)
```


TODO opis

```{r}
dto <- df %>% filter(!is.na(RE_DATE)) %>% 
  mutate(RE_DATE = floor_date(RE_DATE, "1 day")) %>% 
  group_by(PATIENT_ID, RE_DATE) %>% 
  summarize_all(last) %>% 
  ungroup() %>% 
  mutate(DAYS_TO_OUTCOME = difftime(floor_date(DISCHARGE_TIME, "1 day"), RE_DATE, unit="days"))
dto %>% summarise(DAYS_TO_OUTCOME = quantile(DAYS_TO_OUTCOME, c(0, 0.25, 0.5, 0.75,1)), quantile = c("min", "1st", "2nd", "3rd", "max"))
```

```{r}
hist(as.numeric(dto$DAYS_TO_OUTCOME, unit="days"), breaks=38, freq=FALSE)
```
```{r}
df %>% filter(RE_DATE > DISCHARGE_TIME) %>% count(PATIENT_ID)
```


### Wyniki badań
Pozostałe `r ncol(df)-7` kolumn zawiera wartości atrybutów, które reprezentują rodzaje miar zebranych podczas każdego badania.

Nazwy kolumn zostały poddane następującym transformacjom:

* TODO

```{r renaming attributes names}
df <- df %>%
  rename("NT-proBNP" = "Amino-terminal brain natriuretic peptide precursor(NT-proBNP)") %>%
  rename_with(~str_c(str_replace(.x, "\\(%\\)", ""), "_percent"), contains("(%)")) %>%
  rename_with(~str_replace(.x, "\\(#\\)", "")) %>%
  rename_with(tolower, matches("^[[:upper:]]{1}[[:lower:]]+", ignore.case = FALSE)) %>%
  rename_with(~str_replace_all(.x, "[ |-]", "_"))
str_sort(colnames(df[,-(1:7)]))
```


## Czyszczenie zbioru danych

TODO

### Puste rekordy w zbiorze

W powyższej głównej zauważono wystąpienia wartości brakujących dla kolumny `RE_DATE`. 
Szybkie sprawdzenie wykazuje, że dla wierszy, gdzie nie ma atrybut `RE_DATE` przyjmuje wartość 'NA', wartości wszystkich atrybutów pochodzących z badań krwi, również przyjmują wartość 'NA'.
```{r empty rows check}
all(sapply(df[is.na(df$RE_DATE), -c(1,3:7)], is.na))
```
Fakt, że wiersze te są właściwie puste, jest podstawą do ich usunięcia ze zbioru.

```{r clear-empty}
df = df[!is.na(df$RE_DATE),]
```

Po tej zmianie w zbiorze pozostało `r nrow(df)` wierszy i `r length(unique(df$PATIENT_ID))` unikalnych identyfikatorów pacjentów.

TODO komentarz do usunięcia

### Kategorie badań

Wstępnę analiza danych sugeruje wskazuje, że wiele wartości atrybutów jest oznaczona wartością 'NA'.
W poniższych blokach kodu, wyliczana jest liczba elementów, które mają wartość inną niż 'NA' dla każdego wiersza.

```{r historam of number of not NA values per row}
row.counts <- rowSums(sapply(df[,-(1:7)], function(x) !is.na(x)))
summary(row.counts)
```

```{r hist 1, echo=FALSE}
hist(row.counts, breaks=(ncol(df)-7), xlab="Not empty elements in each record", main="")
```
TODO analiza i wnioski

* prawie połowa rekordów ma zaledwie jeden wynik badania.
* co ciekawe, druga i trzecia pod względem liczości grupa rekordów ma odpowiednio po 24 i 23 elementy.
* Można dokonać analizy, czy te grupy powstają losowo, czy mają jakiś wspólny podzbiór -> analiza zbiorów częstych.


### Współwystępowanie kategorii
Zauważamy, że dużo NA, wynika to z tego, że badania są rozrzucone.
Badanie zbiorów, czy któreś są częstsze niż inne.
```{r transactions}
transactions <- sapply(df[,-(1:7)], function(x) !is.na(x))
```

Ilość unikalnych transakcji
```{r unique transactions count}
length(unique(apply(transactions, 1, function(x) which(x))))
```

Szukamy maksymalnych domkniętych zbiorów częstych - sprawdzamy czy badania występują w grupach.

```{r apriori}
itemsets <- apriori(transactions, parameter = list(target="closed frequent itemsets", support=.05, minlen=1, maxlen=30, maxtime=60))
mc_itemsets <- itemsets[is.maximal(itemsets)]
inspect(head(sort(mc_itemsets, by = 'support'), 10))
```

TODO wnioski ze zbiorów częstych


Wyniki różnych testów prawdopodobnie pojawiały się w systemie o różnych porach, dlatego można je razem agregować.

### Badania poszczególnych pacjentów

TODO Analiza ilości badań przeprowadzonych jednemu pacjentowi. 
```{r group by patient id}
gb.patient_id <- df %>% group_by(PATIENT_ID) %>% fill(everything()) %>% summarise_all(last)
rc.gb.patient_id <- rowSums(sapply(gb.patient_id[,-(1:7)], function(x) !is.na(x)))
hist(rc.gb.patient_id, breaks=(ncol(gb.patient_id)-7), xlab="Number of test categories per patient", main="")
```



```{r group by patient id summary}
summary(rc.gb.patient_id)
```
TODO

Zauważamy, że część pacjentów ma niewiele przeprowadzonych rodzajów badań. W zbiorze danych pozostawimy tylko tych, którzy mają ponad *TODO* wykonanych rodzajów badań.

TODO analityczne wybranie tej wartości  
* procent pełnych kolumn
* procent pozostawionych pacjentów
* wartość progu

```{r}
n_tests <- data.frame(PATIENT_ID = gb.patient_id$PATIENT_ID, number_of_tests = rc.gb.patient_id)
cols_cnt <- ncol(df) - 7
th_seq <- seq(0.5, 1.0, by=.025)
cls_vec <- c()
pts_vec <- c()
for(th in th_seq) {
  tmp <- n_tests %>% filter(number_of_tests < cols_cnt*th)
  dt <- gb.patient_id %>% filter(!(PATIENT_ID %in% tmp$PATIENT_ID))
  fl_cols <- mean(colSums(sapply(dt[,-(1:7)], is.na)) == 0)
  pnts <- length(unique(dt$PATIENT_ID)) / length(unique(gb.patient_id$PATIENT_ID))
  cls_vec <- append(cls_vec, fl_cols)
  pts_vec <- append(pts_vec, pnts)
}
test_df <- data.frame(threshold=th_seq, full_cols=cls_vec, patients_left=pts_vec)
ggplot(test_df, aes(x=threshold)) +
  geom_line(aes(y=full_cols, color="Full columns")) + 
  geom_line(aes(y=patients_left, color="Patients left")) + 
  labs(color="Legend") +
  geom_vline(xintercept=0.65, linetype = "longdash")
```

```{r remove poorly tested patients}
threshold <- 0.65
patients_to_be_removed <- n_tests %>% filter(number_of_tests < cols_cnt * threshold)
df <- df %>% filter(!(PATIENT_ID %in% patients_to_be_removed$PATIENT_ID))
```

Po usunięciu rekordów pacjentów, u których przeprowadzono mało badań, pozostało `r length(unique(df$PATIENT_ID))` unikalnych pacjentów.


### Brakujące wartości w kategoriach

```{r number of missing values in each column}
gb.patient_id <- df %>% group_by(PATIENT_ID) %>% fill(everything()) %>% summarise_all(last)
knitr::kable(
sort(colSums(sapply(gb.patient_id[,-(1:7)], is.na)))
)
```

## Dodatkowe cechy

* TODO days to outcome

## Ostateczny kształt zbioru

```{r g2}
g2 <- df %>% 
  mutate(RE_DATE = floor_date(RE_DATE, '1 day')) %>% 
  group_by(PATIENT_ID, RE_DATE) %>% 
  fill(everything()) %>% 
  summarise_all(last) %>% 
  ungroup()
row.counts.g2 <- rowSums(sapply(g2[,-(1:7)], function(x) !is.na(x)))
hist(row.counts.g2, breaks=(ncol(g2)-7))
```


# Techniczne

## Wszytkie użyte pakiety

```{r}
unique(c(.packages(), loadedNamespaces()))
```
