---
title: "Raport - badania krwi pacjentów zakazonych COVID-19"
author: "Wojciech Taisner"
date: "`r format(Sys.time(), '%d %B, %Y')`"
knit: (function(input_file, encoding) {
  out_dir <- 'html';
  rmarkdown::render(input_file, encoding=encoding, output_file=file.path(dirname(input_file), out_dir, 'index.html'))
 })


output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Użyte biblioteki

```{r libraries, message=FALSE}
library(readxl)
library(httr)
library(arules)
library(tidyr)
library(dplyr)
library(lubridate)
library(stringr)
library(ggplot2)
library(purrr)
library(broom)
library(tibble)
library(plotly)
```

```{r utils, echo=FALSE}
'%!in%' <- function(x,y)!('%in%'(x,y))
```

# Przetwarzanie zbioru danych
## Odczyt danych
Odczyt danych przeprowdzony jest bezośrednio ze strony, aby zapewenić stałą wartość początkową dla każdego uruchomienia.
Dodatkowo uzupełniane są brakujące dane identyfikatory pacjentów ```PATIENT_ID```. Wartości brakujące wynikają ze sposobu przetwarzania scalonych komórek pliku źródłowego.
```{r read-data, message=FALSE, results='hide'}
# https://stackoverflow.com/a/41368947
url <- "http://www.cs.put.poznan.pl/dbrzezinski/teaching/zed/wuhan_blood_sample_data_Jan_Feb_2020.xlsx"
GET(url, write_disk(tf <- tempfile(fileext = ".xlsx")))
df <- read_excel(tf) %>% fill(PATIENT_ID)
```

## Atrybuty zbioru danych
Surowy zbiór danych zawiera `r ncol(df)` atrybutów i `r nrow(df)` wierszy.  

Atrybuty zbioru danych można potwierdzić na dwie grupy:

* Atrybuty ogólne - zawierają etykiety, podstawowe dane pacjenta(płeć, wiek, identyfikator, datę przyjęcia i wypisu, rezultat) oraz datę wykonania badania
* Wyniki badań - w kolumnach są umieszczone wartości poszczególnych badanych właściwości krwi

### Brakujące dane

Poza danymi niedostępnymi (`NA`) w zbiorze danych wsytępują dane brakujące, oznakowane wartością `-1`.
Poniższa tabela pokazuje ilość takich wartości w każdej kolumnie, o ile te wartości występują.

```{r}
df %>% pivot_longer(-c(RE_DATE,`Admission time`, `Discharge time`)) %>% filter(value==-1) %>% count(name)
```


Dla kolumny `Platelet count` warkości brakujących jest mało, liczby `-1` zostaną zamienione na `NA`.

```{r}
df <- df %>% mutate(`Platelet count` = if(is.na(`Platelet count`) || `Platelet count` != -1) `Platelet count` else NA)
```

Dla kolumny `2019-nCoV nucleic acid detection` sprawdzimy całkowitą ilość wartości różnych od `NA`.

```{r}
df %>% 
  pivot_longer(-c(RE_DATE,`Admission time`, `Discharge time`)) %>% 
  filter(name=="2019-nCoV nucleic acid detection") %>% 
  filter(!is.na(value)) %>% count(name)
```

Wszystkie wartości w kolumnie `2019-nCoV nucleic acid detection` różne od `NA` wynoszą `-1`, w związku z tym ta kolumna jest właściwie nieprzydatna. Mimo to na ten moment postanowiono nie zmieniać wartości w tej kolumnie, ewentualne zmiany można wykonać w dalszych krokach.

### Atrybuty ogólne
Pierwszych siedem kolumn to atrybuty ogólne, reprezentują następująco:
  
* PATEINT_ID - sztuczny identyfikator pacjenta
* RE_DATE - najpewniej jest to data wprowadzenia wyniku badań próbki krwi do systemu
* age - wiek pacjenta
* gender - płeć pacjenta, przyjmuje wartość 1 albo 2, ale z poisu zbioru danych nie wynika wprost, które oznaczenie jest przypisane do której płci
* Admission time - czas przyjęcia pacjenta do szpitala
* Discharge time - czas zakończenia leczenia (w skutek wypisu pacjenta lub jego śmierci)
* outcome - rezultat, przyjmuje wartość 0 jeżeli pacjent został wyleczony, lub wartość 1 jeżeli zmarł.

Nazwy wyżej wymienionych atrybutów zostaną przeformatowane, będą pisane wielkimi literami, a ewentualne spacje będą zamieniane na znak podkreślinka `_`, w ten sposób atrbuty ogólne będą łatwo odróżnialne od pozostałych atrybutów.

```{r rename top 7 columns}
df <- df %>% rename_with(~ toupper(gsub(" ", "_", .x, fixed = TRUE)), 1:7)
```

Pola `GENDER` i `OUTCOME` zostaną dodatkowo zmienione na typ `factor` - z typu numerycznego zamienione zostaną na zmienne nominalne.
Do tego trzeba przeprowadzić identyfikację typu płci.

Wartości płci nie są jawnie opisane, w artykule źródłowym została natomiast podana proporcja pacjentów danej płci, co powinno umożliwić okreslenie właściwego przypisania.
```{r}
knitr::kable(
df %>% group_by(PATIENT_ID) %>% summarise_all(last) %>% count(GENDER) %>% rename("count" = "n"),
align="lc"
)
```


Wniosek:  

* Mężczyźni - wartość `1`  
* Kobiety - wartość `2`

```{r factorize}
df <- df %>% mutate(across("GENDER", ~factor(., levels=c(1,2), labels=c("MALE", "FEMALE")))) %>%
  mutate(across("OUTCOME", ~factor(., levels=c(0,1), labels=c("CURED","DECEASED"))))
```

Poniżej można zapoznać się z analizą wartości dla atrybutów ogólnych.
Wartość atrybutu `RE_DATE` ma unikalną wartość dla kazdego wiersza.

```{r re_date summary}
knitr::kable(summary(select(df, RE_DATE)))
```
Pozostałe z atrybtów ogólnych, są wspólne dla każdego pacjenta, zastosowano transformację do zniwelowania skutków duplikacji.

```{r top summary}
options(knitr.kable.NA = '')
knitr::kable(
  summary(
    df %>% 
      select(c(1,3:7)) %>% 
      group_by(PATIENT_ID) %>% 
      summarise_all(last)
    )
  )
```
Liczba unikatowych identyfikatorów pacjentów wynosi `r length(unique(df$PATIENT_ID))`.

### Czas hosptializacji

TODO

Ta sekcja poświęcona jest analizie długości hospitalizacji poszczególnych grup pacjentów.

```{r, echo=FALSE}
ht <- df %>% select(1:7) %>% select(-RE_DATE) %>% 
  group_by(PATIENT_ID) %>% summarise_all(last) %>% ungroup() %>% 
  mutate(HOSPITALIZATION_TIME = difftime(ceiling_date(DISCHARGE_TIME, "1 day"), floor_date(ADMISSION_TIME, "1 day"), unit="days"))

knitr::kable(
ht %>% 
  summarise(HOSPITALIZATION_TIME = quantile(HOSPITALIZATION_TIME, c(0, 0.25, 0.5, 0.75,1)), quantile = c("min", "1st", "2nd", "3rd", "max"))
)
```

```{r, echo=FALSE}
ggplot(ht, aes(as.numeric(HOSPITALIZATION_TIME, unit="days"), fill=OUTCOME)) + geom_histogram(binwidth = 1) + xlab("HOSPITALIZATION DAYS")
```

```{r, echo=FALSE}
knitr::kable(
ht %>%
  select(-PATIENT_ID, -ADMISSION_TIME, -DISCHARGE_TIME) %>% group_by(OUTCOME, GENDER) %>% 
  summarise_all(median)
)
```





### Wyniki badań
Pozostałe `r ncol(df)-7` kolumn zawiera wartości atrybutów, które reprezentują rodzaje miar zebranych podczas każdego badania.

Nazwy kolumn zostały poddane następującym transformacjom:

* Zamieniono długie nazwy kolumn na krótkie, skrótowe odpowiedniki, na podstawie nazw medycznych (częściowy *code book* dostępny jest w repozytorium)
* oznaczenia `(%)` zamieniono na suffix `_percent`
* oznaczenia `(#)` usunięto
* nazwy zaczynajace się wielką literą i poza tym skłądające się z małych liter zamieniono na odpowiedniki skłądające się wyłącznie z małych znaków, jednak skrótowce zostały zachwowane
* znak spacji ` ` i myślnika `-` zamieniono na podkreślenie dolne `_` ze względu na łatwość odwołania się do kolumn

Poniższy blok kodu szczegółowo ukazuje zatosowane transfomrmacje, jednocześnie prezentowana są ostatenczne nazwy kolumn wyników badań.

```{r renaming attributes names}
df <- df %>%
  rename("NT-proBNP" = "Amino-terminal brain natriuretic peptide precursor(NT-proBNP)") %>%
  rename("2019-nCov-detection" = "2019-nCoV nucleic acid detection") %>%
  rename("aPPT" = "Activation of partial thromboplastin time") %>%
  rename("ALP" = "Alkaline phosphatase") %>%
  rename("AAT" = "aspartate aminotransferase") %>%
  rename("FDPs" = "Fibrin degradation products") %>%
  rename("ALT" = "glutamic-pyruvic transaminase") %>%
  rename("hs-CRP" = "High sensitivity C-reactive protein") %>%
  rename("hs-cTnI" = "Hypersensitive cardiac troponinI") %>%
  rename("HCV-abs-quant" = "HCV antibody quantification") %>%
  rename("HIV-abs-quant" = "HIV antibody quantification") %>%
  rename("INR" = "International standard ratio") %>%
  rename("LDH" = "Lactate dehydrogenase") %>%
  rename("MCH" = "mean corpuscular hemoglobin") %>%
  rename("MCHC" = "mean corpuscular hemoglobin concentration") %>%
  rename("MCV" = "mean corpuscular volume") %>%
  rename("MPV" = "Mean platelet volume") %>%
  rename("P-LCR" = "platelet large cell ratio") %>%
  rename("PDW" = "PLT distribution width") %>%
  rename("q-t-pallidum-abs" = "Quantification of Treponema pallidum antibodies") %>%
  rename("RCDW-SD" = "RBC distribution width SD") %>%
  rename("RBC_count" = "Red blood cell count") %>%
  rename("RCDW" = "Red blood cell distribution width") %>%
  rename("TNF-alfa" = "Tumor necrosis factorα") %>%
  rename("WBC_count" = "White blood cell count") %>%
  rename("gamma-GT" = "γ-glutamyl transpeptidase") %>%
  rename_with(~str_c(str_replace(.x, "\\(%\\)", ""), "_percent"), contains("(%)")) %>%
  rename_with(~str_replace(.x, "\\(#\\)", "")) %>%
  rename_with(tolower, matches("^[[:upper:]]{1}[[:lower:]]+", ignore.case = FALSE)) %>%
  rename_with(~str_replace_all(.x, "[ |-]", "_"))
str_sort(colnames(df[,-(1:7)]))
```


## Czyszczenie zbioru danych

Niniejsza sekcja jest poświęcona wstępnemu przetwarzniu zbiorów danych, ze szczególnym uwzględnieniem usuwania i scalania wybranych rekordów.

### Puste rekordy w zbiorze

W powyższej głównej zauważono wystąpienia wartości brakujących dla kolumny `RE_DATE`. 
Szybkie sprawdzenie wykazuje, że dla wierszy, gdzie nie ma atrybut `RE_DATE` przyjmuje wartość 'NA', wartości wszystkich atrybutów pochodzących z badań krwi, również przyjmują wartość 'NA'.
```{r empty rows check}
all(sapply(df[is.na(df$RE_DATE), -c(1,3:7)], is.na))
```
Fakt, że wiersze te są właściwie puste, jest podstawą do ich usunięcia ze zbioru.

```{r clear-empty}
df <- df[!is.na(df$RE_DATE),]
```

Po tej zmianie w zbiorze pozostało `r nrow(df)` wierszy i `r length(unique(df$PATIENT_ID))` unikalnych identyfikatorów pacjentów.

### Kategorie badań

Wstępnę analiza danych sugeruje wskazuje, że wiele wartości atrybutów jest oznaczona wartością 'NA'.
Poniższy wykresy wskazuje, ilość wystąpień rekordów badań z danę liczbą wartości (różnych od `NA`).

```{r, echo=FALSE}
ggplot(
  df %>% rowwise() %>% mutate(n_of_values=sum(!is.na(c_across(-(1:7))))),
  aes(n_of_values)
) + geom_histogram(binwidth = 1) +
  xlab("Number of not NA values")
```

Z powyższego histogramu można wyciągnąć kilka wniosków

* Znacząca większość rekordów ma zaledwie jeden wynik badania (jedną wartość).
* Interesujący jest fakt, że druga i trzecia pod względem liczości grupa rekordów ma odpowiednio po 24 i 23 elementy, taki fakt może sugerować, że elementy mogą występować w grupach. Możliwa jest dalsza analiza *współwystępowania ze sobą atrybutów*, np. przy pomocy analizy zbiorów częstych.
* Ze względu na to, że właściwie nie ma rekordów, które opisują wszystkie `r ncol(df) -7` atrybuty, konieczne będzie scalanie rekordów w dalszych krokach.


### Współwystępowanie kategorii

W poprzedniej sekcji stwierdzono, że można przeanalizować współwystępowanie ze sobą poszczególnych atrybutów w rekordach. 
W związku z tym tabela wyników badań zostanie przekształcona do zbioru binarnych transakcji.

```{r transactions}
transactions <- sapply(df[,-(1:7)], function(x) !is.na(x))
```

Sprawdzona zostanie ilość unikalnych transakcji.
```{r unique transactions count}
length(unique(apply(transactions, 1, function(x) which(x))))
```
W zbiorze `r nrow(transactions)` transakcji jest zaledwie `r length(unique(apply(transactions, 1, function(x) which(x))))` różnych typów.  


Aby sprawdzić, czy atrybuty wsytępują w grupach, wyszukiwane są maksymalne domknięte zbiory częste, dla mimalnej wartości `support` równej `5%`.

```{r apriori, message=FALSE}
itemsets <- apriori(transactions, parameter = list(target="closed frequent itemsets", support=.05, minlen=1, maxlen=30, maxtime=60))
mc_itemsets <- itemsets[is.maximal(itemsets)]
```
```{r}
inspect(sort(mc_itemsets, by = 'support'))
```


Otrzymaliśmy 10 maksymalnych domkniętych zbiorów częstych, z czego 7 to zbiory jednolementowe.
Pozostałe 3 zbiory (1, 3 i 10) zawierają wiele elementów. 
Na podstawie elementów składowych, zbiory wieolemelemnetowe zostały zakwalifikowane następująco:

* Zbiór 1 - zawiera elementy typowe dla badania *morfologii krwi* (ang. *Compete blood count (CBC)*)
* Zbiór 3 - zawiera elementy typowe dla badania *biochemii krwi* (ang. *Blood biochemistry*)
* Zbiór 10 - zawiera elementy typowe dla badania *krzepliwości krwi* (ang. *Coagulation*)

Na podstawie uzyskanego wyniku można wnioskować, że ilość elementów w rekordzie może wynikać z procesu technologicznego analizowania próbek krwi.
Sugeruje to, że możliwe będzie scalanie rekordów, np na podstawie dnia wykonania badania (jeśli jednemu pacjentowi przeprowadzono wiele badań w ciagu dnia).

### Badania w czasie

W tej sekcji przeprowadzona zostanie analiza występowania badań w czasie. Ponadto rekordy zostaną pogrupowane według przynależności do zbiorów wyznaczonych w poprzedniej sekcji oraz dwóch dodatkowych klas `NONE` jeśli rekord nie należy do żadnej kategorii i `MULTIPLE` jeśli rekod należy do więcej niż jednej kategorii.

Poniższe blok kodu generuje oetykietowany zbiór rekordów badań, ograniczony jedynie do podstawowych informacji.

```{r}
class_labels <- as(items(sort(mc_itemsets, by="support")), "list")
class_labels <- sapply(class_labels, function(x) x[1])
class_labels[1] <- "Complete blood count"
class_labels[3] <- "Blood biochemistry"
class_labels[10] <- "Coagulation"

classes <- as(items(sort(mc_itemsets, by="support")), "matrix")
labeled <- df %>% rowwise() %>%
  mutate(CLASS = paste(
    which(
      apply(
        (matrix(
          !is.na(c_across(-(1:7))), 
          nrow=nrow(classes), 
          ncol=ncol(classes), 
          byrow=TRUE, 
          dimnames=dimnames(classes)
          ) & classes) == classes, 
        1, 
        all)
      ), collapse=""), 
    .after=OUTCOME ) %>%
  mutate(CLASS = if(CLASS != "" && as.integer(CLASS)>10) "MULTIPLE" else CLASS) %>%
  mutate(CLASS = if(CLASS != "" && CLASS != "MULTIPLE") class_labels[as.integer(CLASS)] else CLASS) %>%
  mutate(CLASS = str_replace(CLASS, "^$", "NONE")) %>%
  mutate(CLASS = str_trim(CLASS)) %>%
  mutate(CLASS = factor(CLASS)) %>%
  rowwise() %>%
  mutate(SIZE = sum(!is.na(c_across(-c(1:8)))), .after=CLASS) %>%
  select(1:9) %>%
  ungroup()

knitr::kable(
  labeled %>% group_by(CLASS) %>% summarize(count = n(), .groups="drop") %>% arrange(desc(count))
)
```

Powyższa tabela prezentuje ilość rekordów przydzielonych do każdej z klas.

Poniższy wykres prezentuje badania danej kategorii według daty wykonania. Dodatkowo każdy punkt jest opisany identyfikatorem pacjenta.

```{r, fig.width=10, fig.height=10, out.width="100%", echo=FALSE}
group.plot <- ggplot(
  labeled, 
  aes(x=RE_DATE, y=CLASS, color=CLASS, label=PATIENT_ID)
  ) +
  geom_jitter(size=0.2) +
  scale_x_datetime(date_breaks = "1 week", date_labels = "%d %b %Y") +
  theme(legend.position="none")

ggplotly(group.plot)
```

Z powyższego wykresu można wywnioskować kilka rzeczy:

* Większość badań została przeprowadzona po 27 stycznia 2020, wszystkie badania zostały wykonane do 19 lutego 2020. Można rozważyć przeprowadzenie dodatkowej analizy skupiającej się na ilości przyjęć i wypisów ze szpitala, w zależności od dnia, aby wyciągnąć dodatkowe wnioski. Fakt ten moze wynikać ze zwiększonej liczby przyjmowanych pacjentów po 27 stycznia 2020.
* Część badań nie była w praktyce przeprowdzana (lub na małą skalę) przed 27 stycznia 2020
* Na wykresie można zaobserwować, że poszczególne punkty są często zgrupowane w "paski" - takie grupy rekordów cechują się małymi różnicami w wartości atrybutu `RE_DATE`. Biorąc pod uwagę fakt, że takie punkty najcześciej przynależą do różnych pacjentów i do tej samej kategorii, należy wnioskować, że poszczególne rodzaje badań były wykonywane równolegle dla wielu pacjentów.

Jednocześnie nie znaleziono żadnych czynników, które podważają sens scalania rekordów.

### Badania poszczególnych pacjentów

TODO Analiza ilości badań przeprowadzonych jednemu pacjentowi. 

```{r group by patient id}
patient_last_results <- df %>% 
  group_by(PATIENT_ID) %>% 
  fill(everything()) %>% 
  summarise_all(last) %>%
  rowwise() %>% 
  mutate(number_of_tests=sum(!is.na(c_across(-(1:7)))), .after=OUTCOME)
  
ggplot(
  patient_last_results, 
  aes(number_of_tests)
  ) + geom_histogram(binwidth = 1)
```



Zauważamy, że część pacjentów ma niewiele przeprowadzonych rodzajów badań. 

TODO analityczne wybranie tej wartości  

* procent pełnych kolumn
* procent pozostawionych pacjentów
* wartość progu

```{r}
veryfication_df <- function(n_tests, cols_cnt, th_seq) {
  cls_vec <- c()
  pts_vec <- c()
  for(th in th_seq) {
    tmp <- n_tests %>% filter(number_of_tests < cols_cnt*th)
    dt <- n_tests %>% filter(!(PATIENT_ID %in% tmp$PATIENT_ID))
    fl_cols <- mean(colSums(sapply(dt[,-(1:8)], is.na)) == 0)
    pnts <- length(unique(dt$PATIENT_ID)) / length(unique(n_tests$PATIENT_ID))
    cls_vec <- append(cls_vec, fl_cols)
    pts_vec <- append(pts_vec, pnts)
  }
    data.frame(threshold=th_seq, full_cols=cls_vec, patients_left=pts_vec)
}

to_plot <- veryfication_df(patient_last_results, ncol(df)-8, seq(0.5, 1.0, by=.025))

ggplot(to_plot, aes(x=threshold)) +
  geom_line(aes(y=full_cols, color="Full columns")) + 
  geom_line(aes(y=patients_left, color="Patients left")) + 
  labs(color="Legend") +
  geom_vline(xintercept=0.675, linetype = "longdash")
```
TODO


W zbiorze danych pozostawimy tylko tych, którzy mają ponad *0.675* wykonanych rodzajów badań.

```{r remove poorly tested patients}
threshold <- 0.675
patients_to_be_removed <- patient_last_results %>% 
  filter(number_of_tests < (ncol(df)-7) * threshold) %>% 
  select(PATIENT_ID)

df <- df %>% filter(PATIENT_ID %!in% patients_to_be_removed$PATIENT_ID)
```

Po usunięciu rekordów pacjentów, u których przeprowadzono mało badań, pozostało `r length(unique(df$PATIENT_ID))` unikalnych pacjentów.


### Brakujące wartości w kategoriach

```{r number of missing values in each column}
knitr::kable(
df %>% 
  group_by(PATIENT_ID) %>% 
  fill(everything()) %>% 
  summarise_all(last) %>% 
  ungroup() %>%
  select(-(1:7)) %>% 
  pivot_longer(everything()) %>%
  mutate(value=is.na(value)) %>%
  group_by(name) %>%
  summarize(value=sum(value), .groups="drop") %>%
  arrange(value)
)

```

## Dodatkowe cechy

* TODO days to outcome

```{r}
df <- df %>%  
  mutate(DAYS_TO_OUTCOME = as.numeric(difftime(
    floor_date(DISCHARGE_TIME, "1 day"), 
    floor_date(RE_DATE, "1 day"), unit="days"
    ), unit="days"), .before=OUTCOME)
df %>% summarise(DAYS_TO_OUTCOME = quantile(DAYS_TO_OUTCOME, c(0, 0.25, 0.5, 0.75,1)), quantile = c("min", "1st", "2nd", "3rd", "max"))
```

```{r}
ggplot(df, aes(DAYS_TO_OUTCOME)) + geom_histogram(binwidth = 1)
```


### Agregacja wierszy według daty badania

```{r g2}
df <- df %>% 
  mutate(RE_DATE = floor_date(RE_DATE, '1 day')) %>% 
  group_by(PATIENT_ID, RE_DATE) %>% 
  fill(everything()) %>% 
  summarise_all(last) %>% 
  ungroup() %>%
  rowwise() %>%
  mutate(number_of_tests=sum(!is.na(c_across(-(1:8)))), .after=OUTCOME)
ggplot(df, aes(number_of_tests)) + geom_histogram(binwidth = 1)
```

```{r}
df <- df %>% select(-number_of_tests)
```


# Zbiór danych


```{r, fig.width=10, fig.height=40}
ggplot(
  df %>% pivot_longer(hs_cTnI:creatinine) %>% filter(!is.na(value)),
  aes(x=OUTCOME, y=value)
) + geom_boxplot() +
scale_x_discrete(labels = abbreviate) + 
facet_wrap(name ~ ., scales="free",ncol=5)
```

## Korelacja

TODO


```{r, message=FALSE, out.width = "100%", fig.align="center", fig.width=10, fig.height=8}
cor_mat <- cor(
  x = df %>% 
    mutate(isMALE = as.numeric(GENDER=="MALE"), 
           isCURED = as.numeric(OUTCOME=="CURED"),
           has_nCOV_test = as.numeric(!is.na(`2019_nCov_detection`))) %>% 
    select(-c(1:8), -"2019_nCov_detection"), 
  use="pairwise.complete.obs"
  )
cor_df = data.frame(round(cor_mat,2)) %>% 
 rownames_to_column() %>%
 pivot_longer(-rowname, names_to="colname")

cor_plot <- ggplot(cor_df, aes(colname, rowname, fill=value)) + 
  geom_tile() +
  scale_fill_gradient2() + 
  theme(axis.text.x=element_text(angle = 90, hjust = 0))

ggplotly(cor_plot)
```

```{r}
knitr::kable(
cor_df %>% filter(colname>rowname) %>% arrange(desc(abs(value))) %>% head(30)
)
```

```{r}
knitr::kable(
tidy(cor.test(df$LDH, as.numeric(df$OUTCOME=="CURED")))
)
```

```{r}
correlations <- df %>% mutate(isCURED=as.numeric(OUTCOME=="CURED")) %>% select(-c(1:2,4:8)) %>% 
  pivot_longer(!isCURED, names_to="attribute", values_to="x_val") %>%
  filter(!is.na(x_val)) %>%
  nest(data = c(x_val, isCURED)) %>%
  mutate(cor_test = map(data, ~tidy(cor.test(.x$x_val, .x$isCURED)))) %>% 
  unnest(cor_test) %>%
  select(attribute, estimate, p.value, conf.low, conf.high) %>% 
  arrange(desc(abs(estimate))) %>% head(15)
knitr::kable(
correlations
)
```

## Analiza wypisów ze szpitala

```{r, fig.width=10, fig.height=6, out.width="100%"}
tseries <- df %>% 
  select(1:8) %>% 
  group_by(PATIENT_ID) %>% 
  summarize(across(everything(), last), .groups="drop") %>% 
  select(-RE_DATE, -AGE, -GENDER, -DAYS_TO_OUTCOME, -PATIENT_ID) %>%
  pivot_longer(ADMISSION_TIME:DISCHARGE_TIME, names_to="TYPE", values_to="DATE") %>%
  mutate(DATE = floor_date(DATE, "days")) %>%
  mutate(TYPE = str_replace(TYPE, "_TIME", "")) %>% 
  count(TYPE, DATE, OUTCOME) %>%
  rename("COUNT" = "n")

tplot <- ggplot(tseries, aes(x=DATE, y=COUNT, fill=OUTCOME)) + 
  geom_col() + 
  scale_x_datetime(date_breaks = "1 week", date_labels = "%d %b %Y") +
  facet_grid(TYPE ~ .)

ggplotly(tplot)
```


# Techniczne

## Wszytkie użyte pakiety

```{r}
unique(c(.packages(), loadedNamespaces()))
```
