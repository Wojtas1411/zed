---
title: "Report"
author: "Me"
date: "Today"
knit: (function(input_file, encoding) {
  out_dir <- 'html';
  rmarkdown::render(input_file, encoding=encoding, output_file=file.path(dirname(input_file), out_dir, 'index.html'))
 })


output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, message=FALSE, echo=FALSE}
library(readxl)
library(httr)
library(arules)
library(tidyr)
library(dplyr)
library(lubridate)
library(stringr)
library(ggplot2)
```

```{r utils, echo=FALSE}
'%!in%' <- function(x,y)!('%in%'(x,y))
```

# Przetwarzanie zbioru danych
## Odczyt danych
Odczyt danych przeprowdzony jest bezośrednio ze strony, aby zapewenić stałą wartość początkową dla każdego uruchomienia.
Dodatkowo uzupełniane są brakujące dane identyfikatory pacjentów ```PATIENT_ID```. Wartości brakujące wynikają ze sposobu przetwarzania scalonych komórek pliku źródłowego.
```{r read-data, message=FALSE, results='hide'}
# https://stackoverflow.com/a/41368947
url <- "http://www.cs.put.poznan.pl/dbrzezinski/teaching/zed/wuhan_blood_sample_data_Jan_Feb_2020.xlsx"
GET(url, write_disk(tf <- tempfile(fileext = ".xlsx")))
df <- read_excel(tf) %>% fill(PATIENT_ID)
```

## Atrybuty zbioru danych
Surowy zbiór danych zawiera `r ncol(df)` atrybutów i `r nrow(df)` wierszy.  

TODO opisać podział na atrybuty ogólne i wyniki badań

### Atrybuty ogólne
Pierwszych siedem kolumn to atrybuty ogólne, reprezentują następująco:
  
* PATEINT_ID - sztuczny identyfikator pacjenta
* RE_DATE - najpewniej jest to data wprowadzenia wyniku badań próbki krwi do systemu
* age - wiek pacjenta
* gender - płeć pacjenta, przyjmuje wartość 1 albo 2, ale z poisu zbioru danych nie wynika wprost, które oznaczenie jest przypisane do której płci
* Admission time - czas przyjęcia pacjenta do szpitala
* Discharge time - czas zakończenia leczenia (w skutek wypisu pacjenta lub jego śmierci)
* outcome - rezultat, przyjmuje wartość 0 jeżeli pacjent został wyleczony, lub wartość 1 jeżeli zmarł.

Nazwy wyżej wymienionych atrybutów zostaną przeformatowane, będą pisane wielkimi literami, a ewentualne spacje będą zamieniane na znak podkreślinka `_`, w ten sposób atrbuty ogólne będą łatwo odróżnialne od pozostałych atrybutów.

```{r rename top 7 columns}
df <- df %>% rename_with(~ toupper(gsub(" ", "_", .x, fixed = TRUE)), 1:7)
```

Pola `GENDER` i `OUTCOME` zostaną dodatkowo zmienione na typ `factor` - z typu numerycznego zamienione zostaną na zmienne nominalne.
Do tego trzeba przeprowadzić identyfikację typu płci.

Wartości płci nie są jawnie opisane, w artykule źródłowym została natomiast podana proporcja pacjentów danej płci, co powinno umożliwić okreslenie właściwego przypisania.
```{r}
knitr::kable(
table(df %>% group_by(PATIENT_ID) %>% summarise_all(last) %>% select(GENDER)),
col.names = c("GENDER", "count")
)
```

Wniosek:  
* Mężczyźni - wartość `1`
* Kobiety - wartość `2`

```{r factorize}
df <- df %>% mutate(across("GENDER", ~factor(., levels=c(1,2), labels=c("MALE", "FEMALE")))) %>%
  mutate(across("OUTCOME", ~factor(., levels=c(0,1), labels=c("CURED","DECEASED"))))
```

Poniżej można zapoznać się z analizą wartości dla atrybutów ogólnych.
Wartość atrybutu `RE_DATE` ma unikalną wartość dla kazdego wiersza.

```{r re_date summary}
knitr::kable(summary(select(df, RE_DATE)))
```
Pozostałe z atrybtów ogólnych, są wspólne dla każdego pacjenta, zastosowano transformację do zniwelowania skutków duplikacji.

```{r top summary}
knitr::kable(
  summary(
    df %>% 
      select(c(1,3:7)) %>% 
      group_by(PATIENT_ID) %>% 
      summarise_all(last)
    )
  )
```
Liczba unikatowych identyfikatorów pacjentów wynosi `r length(unique(df$PATIENT_ID))`.

### Czas hosptializacji

Ta sekcja poświęcona jest analizie długości hospitalizacji poszczególnych grup pacjentów.

```{r, echo=FALSE}
ht <- df %>% select(1:7) %>% select(-RE_DATE) %>% 
  group_by(PATIENT_ID) %>% summarise_all(last) %>% ungroup() %>% 
  mutate(HOSPITALIZATION_TIME = difftime(ceiling_date(DISCHARGE_TIME, "1 day"), floor_date(ADMISSION_TIME, "1 day"), unit="days"))

knitr::kable(
ht %>% 
  summarise(HOSPITALIZATION_TIME = quantile(HOSPITALIZATION_TIME, c(0, 0.25, 0.5, 0.75,1)), quantile = c("min", "1st", "2nd", "3rd", "max"))
)
```

```{r, echo=FALSE}
ggplot(ht, aes(HOSPITALIZATION_TIME)) + geom_histogram(binwidth = 1)
```

```{r, echo=FALSE}
knitr::kable(
ht %>%
  select(-PATIENT_ID, -ADMISSION_TIME, -DISCHARGE_TIME) %>% group_by(OUTCOME, GENDER) %>% 
  summarise_all(median)
)
```





### Wyniki badań
Pozostałe `r ncol(df)-7` kolumn zawiera wartości atrybutów, które reprezentują rodzaje miar zebranych podczas każdego badania.

Nazwy kolumn zostały poddane następującym transformacjom:

* TODO


```{r renaming attributes names}
df <- df %>%
  rename("NT-proBNP" = "Amino-terminal brain natriuretic peptide precursor(NT-proBNP)") %>%
  rename("2019-nCov-detection" = "2019-nCoV nucleic acid detection") %>%
  rename("aPPT" = "Activation of partial thromboplastin time") %>%
  rename("ALP" = "Alkaline phosphatase") %>%
  rename("AAT" = "aspartate aminotransferase") %>%
  rename("FDPs" = "Fibrin degradation products") %>%
  rename("ALT" = "glutamic-pyruvic transaminase") %>%
  rename("hs-CRP" = "High sensitivity C-reactive protein") %>%
  rename("hs-cTnI" = "Hypersensitive cardiac troponinI") %>%
  rename("HCV-abs-quant" = "HCV antibody quantification") %>%
  rename("HIV-abs-quant" = "HIV antibody quantification") %>%
  rename("INR" = "International standard ratio") %>%
  rename("LDH" = "Lactate dehydrogenase") %>%
  rename("MCH" = "mean corpuscular hemoglobin") %>%
  rename("MCHC" = "mean corpuscular hemoglobin concentration") %>%
  rename("MCV" = "mean corpuscular volume") %>%
  rename("MPV" = "Mean platelet volume") %>%
  rename("P-LCR" = "platelet large cell ratio") %>%
  rename("q-t-pallidum-abs" = "Quantification of Treponema pallidum antibodies") %>%
  rename("RCDW-SD" = "RBC distribution width SD") %>%
  rename("RBC_count" = "Red blood cell count") %>%
  rename("RCDW" = "Red blood cell distribution width") %>%
  rename("TNF-alfa" = "Tumor necrosis factorα") %>%
  rename("WBC_count" = "White blood cell count") %>%
  rename("gamma-GT" = "γ-glutamyl transpeptidase") %>%
  rename_with(~str_c(str_replace(.x, "\\(%\\)", ""), "_percent"), contains("(%)")) %>%
  rename_with(~str_replace(.x, "\\(#\\)", "")) %>%
  rename_with(tolower, matches("^[[:upper:]]{1}[[:lower:]]+", ignore.case = FALSE)) %>%
  rename_with(~str_replace_all(.x, "[ |-]", "_"))
str_sort(colnames(df[,-(1:7)]))
```


## Czyszczenie zbioru danych

TODO

### Puste rekordy w zbiorze

W powyższej głównej zauważono wystąpienia wartości brakujących dla kolumny `RE_DATE`. 
Szybkie sprawdzenie wykazuje, że dla wierszy, gdzie nie ma atrybut `RE_DATE` przyjmuje wartość 'NA', wartości wszystkich atrybutów pochodzących z badań krwi, również przyjmują wartość 'NA'.
```{r empty rows check}
all(sapply(df[is.na(df$RE_DATE), -c(1,3:7)], is.na))
```
Fakt, że wiersze te są właściwie puste, jest podstawą do ich usunięcia ze zbioru.

```{r clear-empty}
df <- df[!is.na(df$RE_DATE),]
```

Po tej zmianie w zbiorze pozostało `r nrow(df)` wierszy i `r length(unique(df$PATIENT_ID))` unikalnych identyfikatorów pacjentów.

TODO komentarz do usunięcia

### Kategorie badań

Wstępnę analiza danych sugeruje wskazuje, że wiele wartości atrybutów jest oznaczona wartością 'NA'.
W poniższych blokach kodu, wyliczana jest liczba elementów, które mają wartość inną niż 'NA' dla każdego wiersza.

```{r, echo=FALSE}
ggplot(
  df %>% rowwise() %>% mutate(categories=sum(!is.na(c_across(-(1:7))))),
  aes(categories)
) + geom_histogram(binwidth = 1)
```

TODO analiza i wnioski

* prawie połowa rekordów ma zaledwie jeden wynik badania.
* co ciekawe, druga i trzecia pod względem liczości grupa rekordów ma odpowiednio po 24 i 23 elementy.
* Można dokonać analizy, czy te grupy powstają losowo, czy mają jakiś wspólny podzbiór -> analiza zbiorów częstych.


### Współwystępowanie kategorii
Zauważamy, że dużo NA, wynika to z tego, że badania są rozrzucone.
Badanie zbiorów, czy któreś są częstsze niż inne.
```{r transactions}
transactions <- sapply(df[,-(1:7)], function(x) !is.na(x))
```

Ilość unikalnych transakcji
```{r unique transactions count}
length(unique(apply(transactions, 1, function(x) which(x))))
```

Szukamy maksymalnych domkniętych zbiorów częstych - sprawdzamy czy badania występują w grupach.

```{r apriori}
itemsets <- apriori(transactions, parameter = list(target="closed frequent itemsets", support=.05, minlen=1, maxlen=30, maxtime=60))
mc_itemsets <- itemsets[is.maximal(itemsets)]
inspect(head(sort(mc_itemsets, by = 'support'), 10))
```

TODO wnioski ze zbiorów częstych


Wyniki różnych testów prawdopodobnie pojawiały się w systemie o różnych porach, dlatego można je razem agregować.

### Badania poszczególnych pacjentów

TODO Analiza ilości badań przeprowadzonych jednemu pacjentowi. 
```{r group by patient id}
patient_last_results <- df %>% group_by(PATIENT_ID) %>% fill(everything()) %>% summarise_all(last)
patient_last_results_count <- patient_last_results %>% 
  rowwise() %>% 
  mutate(number_of_tests=sum(!is.na(c_across(-(1:7)))), .after=OUTCOME)
  
ggplot(patient_last_results_count, aes(number_of_tests)) + geom_histogram(binwidth = 1)
```



Zauważamy, że część pacjentów ma niewiele przeprowadzonych rodzajów badań. 

TODO analityczne wybranie tej wartości  
* procent pełnych kolumn
* procent pozostawionych pacjentów
* wartość progu

```{r}
veryfication_df <- function(n_tests, cols_cnt, th_seq) {
  cls_vec <- c()
  pts_vec <- c()
  for(th in th_seq) {
    tmp <- n_tests %>% filter(number_of_tests < cols_cnt*th)
    dt <- patient_last_results_count %>% filter(!(PATIENT_ID %in% tmp$PATIENT_ID))
    fl_cols <- mean(colSums(sapply(dt[,-(1:8)], is.na)) == 0)
    pnts <- length(unique(dt$PATIENT_ID)) / length(unique(n_tests$PATIENT_ID))
    cls_vec <- append(cls_vec, fl_cols)
    pts_vec <- append(pts_vec, pnts)
  }
    data.frame(threshold=th_seq, full_cols=cls_vec, patients_left=pts_vec)
}

to_plot <- veryfication_df(patient_last_results_count, ncol(df)-7, seq(0.5, 1.0, by=.025))

ggplot(to_plot, aes(x=threshold)) +
  geom_line(aes(y=full_cols, color="Full columns")) + 
  geom_line(aes(y=patients_left, color="Patients left")) + 
  labs(color="Legend") +
  geom_vline(xintercept=0.65, linetype = "longdash")
```
TODO


W zbiorze danych pozostawimy tylko tych, którzy mają ponad *0.65* wykonanych rodzajów badań.

```{r remove poorly tested patients}
threshold <- 0.65
patients_to_be_removed <- patient_last_results_count %>% 
  filter(number_of_tests < (ncol(df)-7) * threshold) %>% 
  select(PATIENT_ID)

df <- df %>% filter(PATIENT_ID %!in% patients_to_be_removed$PATIENT_ID)
```

Po usunięciu rekordów pacjentów, u których przeprowadzono mało badań, pozostało `r length(unique(df$PATIENT_ID))` unikalnych pacjentów.


### Brakujące wartości w kategoriach

```{r number of missing values in each column}
knitr::kable(
df %>% 
  group_by(PATIENT_ID) %>% 
  fill(everything()) %>% 
  summarise_all(last) %>% 
  ungroup() %>%
  select(-(1:7)) %>% 
  pivot_longer(everything()) %>%
  mutate(value=is.na(value)) %>%
  group_by(name) %>%
  summarize(value=sum(value), .groups="drop") %>%
  arrange(value)
)

```

## Dodatkowe cechy

* TODO days to outcome

```{r}
df <- df %>%  
  mutate(DAYS_TO_OUTCOME = as.numeric(difftime(
    floor_date(DISCHARGE_TIME, "1 day"), 
    floor_date(RE_DATE, "1 day"), unit="days"
    ), unit="days"), .before=OUTCOME)
df %>% summarise(DAYS_TO_OUTCOME = quantile(DAYS_TO_OUTCOME, c(0, 0.25, 0.5, 0.75,1)), quantile = c("min", "1st", "2nd", "3rd", "max"))
```

```{r}
ggplot(df, aes(DAYS_TO_OUTCOME)) + geom_histogram(binwidth = 1)
```


### Agregacja wierszy według daty badania

```{r g2}
df <- df %>% 
  mutate(RE_DATE = floor_date(RE_DATE, '1 day')) %>% 
  group_by(PATIENT_ID, RE_DATE) %>% 
  fill(everything()) %>% 
  summarise_all(last) %>% 
  ungroup() %>%
  rowwise() %>%
  mutate(number_of_tests=sum(!is.na(c_across(-(1:8)))), .after=OUTCOME)
ggplot(df, aes(number_of_tests)) + geom_histogram(binwidth = 1)
```

```{r}
df <- df %>% select(-number_of_tests)
```
# Zbiór danych


```{r, fig.width=10, fig.height=40}
ggplot(
  df %>% pivot_longer(hs_cTnI:creatinine) %>% filter(!is.na(value)),
  aes(x=OUTCOME, y=value)
) + geom_boxplot() +
scale_x_discrete(labels = abbreviate) + 
facet_wrap(name ~ ., scales="free",ncol=5)
```
# Korelacja

```{r, message=FALSE}
cor_mat <- cor(
  x = df %>% select(-c(1:2,4:8)), 
  y = df %>% mutate(isCURED=OUTCOME=="CURED",isDECEASED=OUTCOME=="DECEASED") %>% select(isCURED, isDECEASED),
  use="pairwise.complete.obs"
  )
knitr::kable(
data.frame(round(cor_mat,2)) %>% arrange(desc(abs(isCURED))) %>% head(15)
)
```


# Techniczne

## Wszytkie użyte pakiety

```{r}
unique(c(.packages(), loadedNamespaces()))
```
