---
title: "Report"
knit: (function(input_file, encoding) {
  out_dir <- 'html';
  rmarkdown::render(input_file, encoding=encoding, output_file=file.path(dirname(input_file), out_dir, 'index.html'))
 })


output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries}
library(readxl)
library(httr)
library(arules)
```
# Data preprocessing
## Read Data
```{r read-data}
# https://stackoverflow.com/a/41368947
url <- "http://www.cs.put.poznan.pl/dbrzezinski/teaching/zed/wuhan_blood_sample_data_Jan_Feb_2020.xlsx"
GET(url, write_disk(tf <- tempfile(fileext = ".xlsx")))
df <- read_excel(tf)
```

## Preprocess
### Set missing PATIENT_ID parameters
```{r}
cur <- 0
for (row in 1:nrow(df)){
  if(is.na(df[row, "PATIENT_ID"])) {
    df[row, "PATIENT_ID"] <- cur
  }
  else {
    cur <- df[row, "PATIENT_ID"]
  }
}
```

## Print summary
```{r}
sapply(df, summary)
```

## "Transakcje" badań
Zauważamy, że dużo NA, wynika to z tego, że badania są rozrzucone.
Badanie zbiorów, czy któreś są częstsze niż inne.
```{r}
# tr.tf - transactions - TRUE/FALSE
tr.tf <- sapply(df[,-(1:7)], function(x) !is.na(x))
transactions <- apply(tr.tf, 1, function(x) colnames(tr.tf)[x])
uni.sets <- unique(transactions)
# tr.str <- sapply(transactions, function(x) paste(x, collapse=", "))
```

```{r}
parse_transaction <- function(arg) {
  if(length(arg) <= 3) {
    return(paste(arg, collapse=", "))
  } else {
    beg <- paste(arg[1:2], collapse=", ");
    rem = length(arg) - 2;
    return(paste(beg, "and", rem, "more"))
  }
}
tr.str <- sapply(transactions, parse_transaction)
```

Ilość unikalnych transakcji
```{r}
length(uni.sets)
```

Najczęstsze transakcje
```{r}
tab <- table(tr.str)
tab[tab == max(tab)]
```

Należałoby znaleźć maksymalne zbiory częste o wysokim support.  

```{r}
itemsets <- apriori(tr.tf, parameter = list(target="closed frequent itemsets", support=.1, minlen=1, maxlen=30, maxtime=60))
itemsets
```

```{r}
inspect(head(sort(itemsets, by = 'support'), 10))
```

Kolejny krok - agregacja transakcji według okna. 

## Grupowanie
Z braku sensownego pomysłu wykonania, porzucamy ideę agregacji według okna, samo grupowanie według patient id musi wystarczyć.
```{r}
```