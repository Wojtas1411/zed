---
title: "Raport - badania krwi pacjentów zakazonych COVID-19"
author: "Wojciech Taisner"
date: "`r format(Sys.time(), '%d %B, %Y')`"
knit: (function(input_file, encoding) {
  out_dir <- 'html';
  rmarkdown::render(input_file, encoding=encoding, output_file=file.path(dirname(input_file), out_dir, 'index.html'))
 })


output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Executive summary

TODO

# Użyte biblioteki

```{r libraries, message=FALSE}
library(readxl)
library(httr)
library(arules)
library(tidyr)
library(dplyr)
library(lubridate)
library(stringr)
library(ggplot2)
library(purrr)
library(broom)
library(tibble)
library(plotly)
library(gridExtra)
library(caret)
library(survival)
```

```{r utils, echo=FALSE}
'%!in%' <- function(x,y)!('%in%'(x,y))
```

# Przetwarzanie zbioru danych
## Odczyt danych
Odczyt danych przeprowdzony jest bezośrednio ze strony, aby zapewenić stałą wartość początkową dla każdego uruchomienia.
Dodatkowo uzupełniane są brakujące dane identyfikatory pacjentów ```PATIENT_ID```. Wartości brakujące wynikają ze sposobu przetwarzania scalonych komórek pliku źródłowego.
```{r read-data, message=FALSE, results='hide'}
# https://stackoverflow.com/a/41368947
url <- "http://www.cs.put.poznan.pl/dbrzezinski/teaching/zed/wuhan_blood_sample_data_Jan_Feb_2020.xlsx"
GET(url, write_disk(tf <- tempfile(fileext = ".xlsx")))
df <- read_excel(tf) %>% fill(PATIENT_ID)
```

## Atrybuty zbioru danych
Surowy zbiór danych zawiera `r ncol(df)` atrybutów i `r nrow(df)` wierszy.  

Atrybuty zbioru danych można potwierdzić na dwie grupy:

* Atrybuty ogólne - zawierają etykiety, podstawowe dane pacjenta(płeć, wiek, identyfikator, datę przyjęcia i wypisu, rezultat) oraz datę wykonania badania
* Wyniki badań - w kolumnach są umieszczone wartości poszczególnych badanych właściwości krwi

### Brakujące dane

Poza danymi niedostępnymi (`NA`) w zbiorze danych wsytępują dane brakujące, oznakowane wartością `-1`.
Poniższa tabela pokazuje ilość takich wartości w każdej kolumnie, o ile te wartości występują.

```{r, echo=FALSE}
knitr::kable(
df %>% pivot_longer(-c(RE_DATE,`Admission time`, `Discharge time`)) %>% filter(value==-1) %>% count(name)
)
```


Dla kolumny `Platelet count` warkości brakujących jest mało, liczby `-1` zostaną zamienione na `NA`.

```{r}
df <- df %>% mutate(`Platelet count` = if(is.na(`Platelet count`) || `Platelet count` != -1) `Platelet count` else NA)
```

Dla kolumny `2019-nCoV nucleic acid detection` sprawdzimy całkowitą ilość wartości różnych od `NA`.

```{r, echo=FALSE}
knitr::kable(
df %>% 
  pivot_longer(-c(RE_DATE,`Admission time`, `Discharge time`)) %>% 
  filter(name=="2019-nCoV nucleic acid detection") %>% 
  filter(!is.na(value)) %>% count(name)
)
```

Wszystkie wartości w kolumnie `2019-nCoV nucleic acid detection` różne od `NA` wynoszą `-1`, w związku z tym ta kolumna jest właściwie nieprzydatna. Mimo to na ten moment postanowiono nie zmieniać wartości w tej kolumnie, ewentualne zmiany można wykonać w dalszych krokach.

### Atrybuty ogólne
Pierwszych siedem kolumn to atrybuty ogólne, reprezentują następująco:
  
* PATEINT_ID - sztuczny identyfikator pacjenta
* RE_DATE - najpewniej jest to data wprowadzenia wyniku badań próbki krwi do systemu
* age - wiek pacjenta
* gender - płeć pacjenta, przyjmuje wartość 1 albo 2, ale z poisu zbioru danych nie wynika wprost, które oznaczenie jest przypisane do której płci
* Admission time - czas przyjęcia pacjenta do szpitala
* Discharge time - czas zakończenia leczenia (w skutek wypisu pacjenta lub jego śmierci)
* outcome - rezultat, przyjmuje wartość 0 jeżeli pacjent został wyleczony, lub wartość 1 jeżeli zmarł.

Nazwy wyżej wymienionych atrybutów zostaną przeformatowane, będą pisane wielkimi literami, a ewentualne spacje będą zamieniane na znak podkreślinka `_`, w ten sposób atrbuty ogólne będą łatwo odróżnialne od pozostałych atrybutów.

```{r rename top 7 columns}
df <- df %>% rename_with(~ toupper(gsub(" ", "_", .x, fixed = TRUE)), 1:7)
```

Pola `GENDER` i `OUTCOME` zostaną dodatkowo zmienione na typ `factor` - z typu numerycznego zamienione zostaną na zmienne nominalne.
Do tego trzeba przeprowadzić identyfikację typu płci.

Wartości płci nie są jawnie opisane, w artykule źródłowym została natomiast podana proporcja pacjentów danej płci, co powinno umożliwić okreslenie właściwego przypisania.
```{r, echo=FALSE}
knitr::kable(
df %>% group_by(PATIENT_ID) %>% summarise_all(last) %>% count(GENDER) %>% rename("count" = "n"),
align="lc"
)
```


Wniosek:  

* Mężczyźni - wartość `1`  
* Kobiety - wartość `2`

```{r factorize}
df <- df %>% 
  mutate(across("GENDER", ~factor(., levels=c(1,2), labels=c("MALE", "FEMALE")))) %>%
  mutate(across("OUTCOME", ~factor(., levels=c(0,1), labels=c("CURED","DECEASED"))))
```

Poniżej można zapoznać się z analizą wartości dla atrybutów ogólnych.
Wartość atrybutu `RE_DATE` ma unikalną wartość dla kazdego wiersza.

```{r re_date summary, echo=FALSE}
knitr::kable(summary(select(df, RE_DATE)))
```
Pozostałe z atrybtów ogólnych, są wspólne dla każdego pacjenta, zastosowano transformację do zniwelowania skutków duplikacji.

```{r top summary, echo=FALSE}
options(knitr.kable.NA = '')
knitr::kable(
  summary(
    df %>% 
      select(c(1,3:7)) %>% 
      group_by(PATIENT_ID) %>% 
      summarise_all(last)
    )
  )
```

Liczba unikatowych identyfikatorów pacjentów wynosi `r length(unique(df$PATIENT_ID))`.


### Wyniki badań
Pozostałe `r ncol(df)-7` kolumn zawiera wartości atrybutów, które reprezentują rodzaje miar zebranych podczas każdego badania.

Nazwy kolumn zostały poddane następującym transformacjom:

* Zamieniono długie nazwy kolumn na krótkie, skrótowe odpowiedniki, na podstawie nazw medycznych (częściowy *code book* dostępny jest w repozytorium)
* oznaczenia `(%)` zamieniono na suffix `_percent`
* oznaczenia `(#)` usunięto
* nazwy zaczynajace się wielką literą i poza tym skłądające się z małych liter zamieniono na odpowiedniki skłądające się wyłącznie z małych znaków, jednak skrótowce zostały zachwowane
* znak spacji ` ` i myślnika `-` zamieniono na podkreślenie dolne `_` ze względu na łatwość odwołania się do kolumn

Poniższy blok kodu szczegółowo ukazuje zatosowane transfomrmacje, jednocześnie prezentowana są ostatenczne nazwy kolumn wyników badań.

```{r renaming attributes names}
df <- df %>%
  rename("NT-proBNP" = "Amino-terminal brain natriuretic peptide precursor(NT-proBNP)") %>%
  rename("2019-nCov-detection" = "2019-nCoV nucleic acid detection") %>%
  rename("aPPT" = "Activation of partial thromboplastin time") %>%
  rename("ALP" = "Alkaline phosphatase") %>%
  rename("AAT" = "aspartate aminotransferase") %>%
  rename("FDPs" = "Fibrin degradation products") %>%
  rename("ALT" = "glutamic-pyruvic transaminase") %>%
  rename("hs-CRP" = "High sensitivity C-reactive protein") %>%
  rename("hs-cTnI" = "Hypersensitive cardiac troponinI") %>%
  rename("HCV-abs-quant" = "HCV antibody quantification") %>%
  rename("HIV-abs-quant" = "HIV antibody quantification") %>%
  rename("INR" = "International standard ratio") %>%
  rename("LDH" = "Lactate dehydrogenase") %>%
  rename("MCH" = "mean corpuscular hemoglobin") %>%
  rename("MCHC" = "mean corpuscular hemoglobin concentration") %>%
  rename("MCV" = "mean corpuscular volume") %>%
  rename("MPV" = "Mean platelet volume") %>%
  rename("P-LCR" = "platelet large cell ratio") %>%
  rename("PDW" = "PLT distribution width") %>%
  rename("q-t-pallidum-abs" = "Quantification of Treponema pallidum antibodies") %>%
  rename("RCDW-SD" = "RBC distribution width SD") %>%
  rename("RBC_count" = "Red blood cell count") %>%
  rename("RCDW" = "Red blood cell distribution width") %>%
  rename("TNF-alfa" = "Tumor necrosis factorα") %>%
  rename("WBC_count" = "White blood cell count") %>%
  rename("gamma-GT" = "γ-glutamyl transpeptidase") %>%
  rename_with(~str_c(str_replace(.x, "\\(%\\)", ""), "_percent"), contains("(%)")) %>%
  rename_with(~str_replace(.x, "\\(#\\)", "")) %>%
  rename_with(tolower, matches("^[[:upper:]]{1}[[:lower:]]+", ignore.case = FALSE)) %>%
  rename_with(~str_replace_all(.x, "[ |-]", "_"))
str_sort(colnames(df[,-(1:7)]))
```


## Czyszczenie zbioru danych

Niniejsza sekcja jest poświęcona wstępnemu przetwarzniu zbiorów danych, ze szczególnym uwzględnieniem usuwania i scalania wybranych rekordów.

### Puste rekordy w zbiorze

W powyższej głównej zauważono wystąpienia wartości brakujących dla kolumny `RE_DATE`. 
Szybkie sprawdzenie wykazuje, że dla wierszy, gdzie nie ma atrybut `RE_DATE` przyjmuje wartość 'NA', wartości wszystkich atrybutów pochodzących z badań krwi, również przyjmują wartość 'NA'.
```{r empty rows check}
all(sapply(df[is.na(df$RE_DATE), -c(1,3:7)], is.na))
```
Fakt, że wiersze te są właściwie puste, jest podstawą do ich usunięcia ze zbioru.

```{r clear-empty}
df <- df[!is.na(df$RE_DATE),]
```

Po tej zmianie w zbiorze pozostało `r nrow(df)` wierszy i `r length(unique(df$PATIENT_ID))` unikalnych identyfikatorów pacjentów.

### Kategorie badań

Wstępnę analiza danych sugeruje wskazuje, że wiele wartości atrybutów jest oznaczona wartością 'NA'.
Poniższy wykresy wskazuje, ilość wystąpień rekordów badań z danę liczbą wartości (różnych od `NA`).

```{r, echo=FALSE}
ggplot(
  df %>% rowwise() %>% mutate(n_of_values=sum(!is.na(c_across(-(1:7))))),
  aes(n_of_values)
) + geom_histogram(binwidth = 1) +
  xlab("Number of not NA values")
```

Z powyższego histogramu można wyciągnąć kilka wniosków

* Znacząca większość rekordów ma zaledwie jeden wynik badania (jedną wartość).
* Interesujący jest fakt, że druga i trzecia pod względem liczości grupa rekordów ma odpowiednio po 24 i 23 elementy, taki fakt może sugerować, że elementy mogą występować w grupach. Możliwa jest dalsza analiza *współwystępowania ze sobą atrybutów*, np. przy pomocy analizy zbiorów częstych.
* Ze względu na to, że właściwie nie ma rekordów, które opisują wszystkie `r ncol(df) -7` atrybuty, konieczne będzie scalanie rekordów w dalszych krokach.


### Współwystępowanie kategorii

W poprzedniej sekcji stwierdzono, że można przeanalizować współwystępowanie ze sobą poszczególnych atrybutów w rekordach. 
W związku z tym tabela wyników badań zostanie przekształcona do zbioru binarnych transakcji.

```{r transactions}
transactions <- sapply(df[,-(1:7)], function(x) !is.na(x))
```

Sprawdzona zostanie ilość unikalnych transakcji.
```{r unique transactions count}
length(unique(apply(transactions, 1, function(x) which(x))))
```
W zbiorze `r nrow(transactions)` transakcji jest zaledwie `r length(unique(apply(transactions, 1, function(x) which(x))))` różnych typów.  


Aby sprawdzić, czy atrybuty wsytępują w grupach, wyszukiwane są maksymalne domknięte zbiory częste, dla mimalnej wartości `support` równej `5%`.

```{r apriori, message=FALSE}
itemsets <- apriori(transactions, parameter = list(target="closed frequent itemsets", support=.05, minlen=1, maxlen=30, maxtime=60))
mc_itemsets <- itemsets[is.maximal(itemsets)]
```
```{r}
inspect(sort(mc_itemsets, by = 'support'))
```


Otrzymaliśmy 10 maksymalnych domkniętych zbiorów częstych, z czego 7 to zbiory jednolementowe.
Pozostałe 3 zbiory (1, 3 i 10) zawierają wiele elementów. 
Na podstawie elementów składowych, zbiory wieolemelemnetowe zostały zakwalifikowane następująco:

* Zbiór 1 - zawiera elementy typowe dla badania *morfologii krwi* (ang. *Compete blood count (CBC)*)
* Zbiór 3 - zawiera elementy typowe dla badania *biochemii krwi* (ang. *Blood biochemistry*)
* Zbiór 10 - zawiera elementy typowe dla badania *krzepliwości krwi* (ang. *Coagulation*)

Na podstawie uzyskanego wyniku można wnioskować, że ilość elementów w rekordzie może wynikać z procesu technologicznego analizowania próbek krwi.
Sugeruje to, że możliwe będzie scalanie rekordów, np na podstawie dnia wykonania badania (jeśli jednemu pacjentowi przeprowadzono wiele badań w ciagu dnia).

### Badania w czasie

W tej sekcji przeprowadzona zostanie analiza występowania badań w czasie. Ponadto rekordy zostaną pogrupowane według przynależności do zbiorów wyznaczonych w poprzedniej sekcji oraz dwóch dodatkowych klas `NONE` jeśli rekord nie należy do żadnej kategorii i `MULTIPLE` jeśli rekod należy do więcej niż jednej kategorii.

Poniższe blok kodu generuje oetykietowany zbiór rekordów badań, ograniczony jedynie do podstawowych informacji.

```{r}
class_labels <- as(items(sort(mc_itemsets, by="support")), "list")
class_labels <- sapply(class_labels, function(x) x[1])
class_labels[1] <- "Complete blood count"
class_labels[3] <- "Blood biochemistry"
class_labels[10] <- "Coagulation"

classes <- as(items(sort(mc_itemsets, by="support")), "matrix")
labeled <- df %>% rowwise() %>%
  mutate(CLASS = paste(
    which(
      apply(
        (matrix(
          !is.na(c_across(-(1:7))), 
          nrow=nrow(classes), 
          ncol=ncol(classes), 
          byrow=TRUE, 
          dimnames=dimnames(classes)
          ) & classes) == classes, 
        1, 
        all)
      ), collapse=""), 
    .after=OUTCOME ) %>%
  mutate(CLASS = if(CLASS != "" && as.integer(CLASS)>10) "MULTIPLE" else CLASS) %>%
  mutate(CLASS = if(CLASS != "" && CLASS != "MULTIPLE") class_labels[as.integer(CLASS)] else CLASS) %>%
  mutate(CLASS = str_replace(CLASS, "^$", "NONE")) %>%
  mutate(CLASS = str_trim(CLASS)) %>%
  mutate(CLASS = factor(CLASS)) %>%
  rowwise() %>%
  mutate(SIZE = sum(!is.na(c_across(-c(1:8)))), .after=CLASS) %>%
  select(1:9) %>%
  ungroup()

knitr::kable(
  labeled %>% group_by(CLASS) %>% summarize(count = n(), .groups="drop") %>% arrange(desc(count))
)
```

Powyższa tabela prezentuje ilość rekordów przydzielonych do każdej z klas.

Poniższy wykres prezentuje badania danej kategorii według daty wykonania. Dodatkowo każdy punkt jest opisany identyfikatorem pacjenta.

```{r, fig.width=10, fig.height=10, out.width="100%", echo=FALSE}
group.plot <- ggplot(
  labeled, 
  aes(x=RE_DATE, y=CLASS, color=CLASS, label=PATIENT_ID)
  ) +
  geom_jitter(size=0.2) +
  scale_x_datetime(date_breaks = "1 week", date_labels = "%d %b %Y") +
  theme(legend.position="none")

ggplotly(group.plot)
```

Z powyższego wykresu można wywnioskować kilka rzeczy:

* Większość badań została przeprowadzona po 27 stycznia 2020, wszystkie badania zostały wykonane do 19 lutego 2020. Można rozważyć przeprowadzenie dodatkowej analizy skupiającej się na ilości przyjęć i wypisów ze szpitala, w zależności od dnia, aby wyciągnąć dodatkowe wnioski. Fakt ten moze wynikać ze zwiększonej liczby przyjmowanych pacjentów po 27 stycznia 2020.
* Część badań nie była w praktyce przeprowdzana (lub na małą skalę) przed 27 stycznia 2020
* Na wykresie można zaobserwować, że poszczególne punkty są często zgrupowane w "paski" - takie grupy rekordów cechują się małymi różnicami w wartości atrybutu `RE_DATE`. Biorąc pod uwagę fakt, że takie punkty najcześciej przynależą do różnych pacjentów i do tej samej kategorii, należy wnioskować, że poszczególne rodzaje badań były wykonywane równolegle dla wielu pacjentów.

Jednocześnie nie znaleziono żadnych czynników, które podważają sens scalania rekordów.

### Badania pacjentów

Kolejna analiza dotyczy ilości różnych atrybutów zbadanych u każdego pacjenta.
W tym celu wyznaczamy wektor wartości ostatnich badań każdego z pacjentów, tj wynik każdego badania jest najmłodszy i różny od `NA`, jeśli dany pacjent nie ma przypisanego żadnego rekordu zawierajacego wartość danego atrybutu, to wartość ta nadal będzie oznakowana jako `NA`. 

```{r group by patient id, echo=FALSE}
patient_last_results <- df %>% 
  group_by(PATIENT_ID) %>% 
  fill(everything()) %>% 
  summarise_all(last) %>%
  rowwise() %>% 
  mutate(number_of_tests=sum(!is.na(c_across(-(1:7)))), .after=OUTCOME)
  
ggplot(
  patient_last_results, 
  aes(number_of_tests)
  ) + 
  geom_histogram(binwidth = 1) + 
  xlab("Number of not NA values")
```

Powyższy histogram obrazuje rozkład ilości badań wykonanych pacjentom.
Zauważalna jest grupa wartości odstających - pacjentów którym wykonano znacząco mniej rodzajów badań.
Rekordy tych pacjentów zostaną usunięte ze zbioru danych.

#### Usuwanie pacjentów z znacząco mniejszą liczbą badań

W celu usunięcia pacjentów z mniejszą ilością badań, zostanie wyznaczony próg minimlanej ilości badań.
Próg ten przyjmuje wartość między 0 a 1, należy go interpretować jako minimalną procentową ilość badań, które musi mieć wykonany pacjent.
Maksimum stanowi ilość wszystkich badanych atrybutów, czyli `r ncol(df)-7`.

Wartość progu została wyznaczona analitycznie, w następujący sposób;
dla każdej wartości progu z zakresu od 0.5 do 1 z krokiem 0.025, wyznaczona został procent pozostałych (nie odrzuconych) pacjentów, w stosunku do liczby początkowej, a także procent kolumn, które nie zawierają żadnej wartości `NA`.

Uzyskane dane zostały przedstawione na poniższym wykresie.

```{r, echo=FALSE}
veryfication_df <- function(n_tests, cols_cnt, th_seq) {
  cls_vec <- c()
  pts_vec <- c()
  for(th in th_seq) {
    tmp <- n_tests %>% filter(number_of_tests < cols_cnt*th)
    dt <- n_tests %>% filter(!(PATIENT_ID %in% tmp$PATIENT_ID))
    fl_cols <- mean(colSums(sapply(dt[,-(1:8)], is.na)) == 0)
    pnts <- length(unique(dt$PATIENT_ID)) / length(unique(n_tests$PATIENT_ID))
    cls_vec <- append(cls_vec, fl_cols)
    pts_vec <- append(pts_vec, pnts)
  }
    data.frame(threshold=th_seq, full_cols=cls_vec, patients_left=pts_vec)
}

to_plot <- veryfication_df(patient_last_results, ncol(patient_last_results)-8, seq(0.5, 1.0, by=.025))

threshold <- 0.65

ggplot(to_plot, aes(x=threshold)) +
  geom_line(aes(y=full_cols, color="Full columns")) + 
  geom_line(aes(y=patients_left, color="Patients left")) + 
  labs(color="Legend") +
  geom_vline(xintercept=threshold, linetype = "longdash") + 
  ylab("percent")
```

Wybrana wartość została oznaczona na wykresie czarną przerywaną linią, wynosi `r threshold` i odpowiada `r round((ncol(df)-7)*threshold)` atrybutom.
Taka wartość progowa pozwala na zachowanie znaczącej większości pacjentów w zbiorze, uzyskanie lepszego efektu poprzez jej zwiększenie, wiązałoby się ze znaczącym zmniejszeniem ilości pacjentów w zbiorze wynikowym.


```{r remove poorly tested patients}
patients_to_be_removed <- patient_last_results %>% 
  filter(number_of_tests < (ncol(df)-7) * threshold) %>% 
  select(PATIENT_ID)

df <- df %>% filter(PATIENT_ID %!in% patients_to_be_removed$PATIENT_ID)
```

Po usunięciu rekordów pacjentów, u których przeprowadzono mało badań, pozostało `r length(unique(df$PATIENT_ID))` unikalnych pacjentów.


#### Brakujące wartości w kategoriach

Poniższy histogram prezentuje ilość kolumn, według ilości brakujących wartości badań w każdej kolumnie, biorąc pod uwagę wszystkie wyniki każdego z pacjentów. Dodatkowo nazwy kolumn zostały oznaczone według przynależności do jednej z grup badań (sekcja "Współwystępowanie badań"), lub opsiane wartością NONE, jesli nie należą do żadnej z nich.

```{r number of missing values in each column, echo=FALSE}
column.counts <- df %>% 
  group_by(PATIENT_ID) %>% 
  fill(everything()) %>% 
  summarise_all(last) %>% 
  ungroup() %>%
  select(-(1:7)) %>% 
  pivot_longer(everything()) %>%
  mutate(value=is.na(value)) %>%
  group_by(name) %>%
  summarize(value=sum(value), .groups="drop") %>%
  arrange(value)

#knitr::kable(column.counts)

```

```{r, echo=FALSE, out.width="100%"}
class_labels <- as(items(sort(mc_itemsets, by="support")), "list")

assign_color <- function(value, labels) {
  sapply(value, function(x) {
    if(x %in% labels[[1]]) {
      "Complete blood count"
    }
    else if(x %in% labels[[3]]) {
      "Blood biochemistry"
    }
    else if(x %in% labels[[10]]) {
      "Coagulation"
    } else {
      "NONE"
    }
  })
}


plt_mis_vals <- ggplot(
  column.counts %>% mutate(color=assign_color(name, class_labels)), 
  aes(x=value, fill=color)
  ) + 
  geom_histogram(binwidth=2) + 
  xlab("Number of missing values")

ggplotly(plt_mis_vals)
```

Na powyższym wykresie możemy zaobserwować, że znacząca część badań została wykonana wszystkim pozostałym w zbiorze pacjentom. Dodatkowo, wszystkie testy z grupy *biochemii krwi* i *morfologii* zostały przeprowadzone u większości pacjentów.

W kolejnych krokach można rozważyć odrzucenie pacjentów, którzy nie mają wykonanych wszystkich testów w tych dwóch grupach.


## Agregacja wierszy według daty badania

W zwiazku z brakiem wykrytycyh preciwskazań, w tym kroku przeprowadzono scalanie wyników badań każdego pacjenta, według dnia jego wykonania, tj. wszystkie rekordy z danego dnia zostaną scalone w jeden rekord, który zawiera wszystkie, najbardziej aktualne wyniki z danego dnia.

```{r group by day}
df <- df %>% 
  mutate(RE_DATE = floor_date(RE_DATE, '1 day')) %>% 
  group_by(PATIENT_ID, RE_DATE) %>% 
  fill(everything()) %>% 
  summarise_all(last) %>% 
  ungroup()
```

Po tej transformacji, w zbiorze danych pozostało `r nrow(df)` rekordów.

```{r, echo=FALSE}
ggplot(
  df %>%
  rowwise() %>%
  mutate(number_of_tests=sum(!is.na(c_across(-(1:7)))), .after=OUTCOME), 
  aes(number_of_tests)
  ) + 
  geom_histogram(binwidth = 1) + 
  xlab("Number of not NA values")

```

Powyższy histogram prezentuje ilość rekordów zawierających daną ilość wyników badań. Pomimo znacznej ilości rekordów zawierajacych tylko jeden wynik badania, obserwujemy wzrost w ilości rekordów zawierających ponad 40 wyników badań, w porównaniu do wyników przed agregacją. 

# Zbiór danych

Ta sekcja jest poświęcona analizie danych w zbiorze.

## Analiza wybranych parametrów podstawowych


### Płeć

Poniższy wykres prezentuje ilość przypadków z dany rezultatem leczenia w stosunku do płci pacjenta. Obserwujemy relatywnie małą ilość zmarłych kobiet w stosunku do zmarłych mężczyzn.

```{r, echo=FALSE}
gender.plot <- ggplot(
  df %>% select(PATIENT_ID, GENDER, OUTCOME) %>% distinct() %>% count(GENDER, OUTCOME) %>% rename(COUNT = n),
  aes(x=OUTCOME, y=GENDER, size=COUNT, color=GENDER)
) + geom_point()

ggplotly(gender.plot)
```

### Wiek

Poniższy wykres przedstawia rozkład wieku w zależności od wyniku leczenia i płci pcajenta. Większość ze zmarłych pacjentów ma powyżej 60 lat, co sugeruje że grupa starszych pacjentów jest bardziej narażona na śmierć w wyniku choroby spowodowanej zarażeniem wirusem.

```{r, echo=FALSE}
age <- ggplot(
  df %>% select(PATIENT_ID, AGE, GENDER, OUTCOME) %>% distinct(),
  aes(x=OUTCOME, y=AGE)
) + 
  geom_boxplot() +
  facet_grid(. ~ GENDER)

ggplotly(age)
```

## Analiza wartości parametrów

Poniższy zbiór wykresów przedstawia rozkład poszczególnych wyników badań, w zależności od rezultatu leczenia. Część wykresów jest nieczytelna przez występowanie wartości odstających (outlierów).

```{r, fig.width=10, fig.height=40, echo=FALSE}
ggplot(
  df %>% pivot_longer(hs_cTnI:creatinine) %>% filter(!is.na(value)),
  aes(x=OUTCOME, y=value)
) + geom_boxplot() +
facet_wrap(name ~ ., scales="free",ncol=5)
```

W niektórych wypadkach możemy zaobserwować istotne różnice między zbiorami pacjentów wyleczonych i zmarłych, są to między innymi parametry takie jak: `albumin`, `hs_CRP`, `lymphoocytes_percent` i `monocythes_percent`.

## Korelacja

Poniższy wykres przedstawia wartość współczynnika korelacji Pearsona między wszystkimi parametrami liczbowymi w zbiorze. Parametry nominalne `GENDER` i `OUTCOME`, ze względu na to zę mają tylko dwie wartości, zostały zakodowane jako `isMALE` i `isCURED`. Dodatkowo, ze parametr `2019_nCov_detection` ze względu na stałą wartość, został zamieniony na parametr `has_nCOV_test`, który indykuje czy w danym badaniu wykonano taki test.

```{r, message=FALSE, echo=FALSE, out.width = "100%", fig.align="center", fig.width=10, fig.height=8}
cor_mat <- cor(
  x = df %>% 
    mutate(isMALE = as.numeric(GENDER=="MALE"), 
           isCURED = as.numeric(OUTCOME=="CURED"),
           has_nCOV_test = as.numeric(!is.na(`2019_nCov_detection`))) %>% 
    select(-c(1:8), -"2019_nCov_detection"), 
  use="pairwise.complete.obs"
  )
cor_df = data.frame(round(cor_mat,2)) %>% 
 rownames_to_column() %>%
 pivot_longer(-rowname, names_to="colname")

cor_plot <- ggplot(cor_df, aes(colname, rowname, fill=value)) + 
  geom_tile() +
  scale_fill_gradient2() + 
  theme(axis.text.x=element_text(angle = 90, hjust = 0))

ggplotly(cor_plot)
```

Ponadto w poniższej tabeli zebrano 30 par atrybutów z największym współczynnikiem korelacji Pearsona.

```{r, echo=FALSE}
knitr::kable(
cor_df %>% filter(colname>rowname) %>% arrange(desc(abs(value))) %>% head(30)
)
```

Można zaobserwować wiele mocno skorelowanych parametrów, m.in:

* miary `MPV`, `P-LCR` i `PDW` odnoszą się do wielkości płytek krwi (odpowiednio: *mean platelet volume*, *platelet - large cell ratio* i *platelet distribution width*), więc ich wysokie skorelowanie jest łatwe do wyjaśnienia.
* `lymphocytes_percent` i `neutrophils_percent` - określają proporcje białych krwniek danego typu w krwi pacjenta
* `INR` z definicji jest właściwie liniowo zależna od `prothrombin_time`
* `direct_bilirubin` jest składową `total_bilirubin`

Dodatkowo sprawdzona zostanie korelacja poszczególnych parametrów z wynikiem leczenia chorego (`isCured`). Poniższa tabela zawiera wartości korelacji Pearsona wraz z przedziałem ufności i p-wartością (wszystkie z pokazanych korelacji są istotne statysytycznie) dla 15 najmocniej skorelowanych parametrów.

```{r, echo=FALSE}
correlations <- df %>% mutate(isCURED=as.numeric(OUTCOME=="CURED")) %>% 
  select(-c(1:2,4:7)) %>% 
  select(-"2019_nCov_detection") %>% # remove this property because it has no standard deviation
  pivot_longer(!isCURED, names_to="attribute", values_to="x_val") %>%
  filter(!is.na(x_val)) %>%
  nest(data = c(x_val, isCURED)) %>%
  mutate(cor_test = map(data, ~tidy(cor.test(.x$x_val, .x$isCURED)))) %>% 
  unnest(cor_test) %>%
  select(attribute, estimate, p.value, conf.low, conf.high) %>% 
  arrange(desc(abs(estimate))) %>% head(15)
knitr::kable(
correlations
)
```

Z powyższej tabli wynika, że wpływ na wynik choroby pacjenta mają: 

* stan układu odpornościowego (wysoka proporcja `lymphocyte` i niska proporcja `neutrophils`)
* stan układu krzepnięcia (`prothrombin_activity`, `D_D_dimer`, `FDPs`)
* `hs_CRP` i `LDH` których podwyższony stan wskazuje na dużą ilość uszkodzonych komórek
* wysoki poziom `albumin` - białek odpowiadających za transport odczynników we krwi (w tym leków) i regulację ilości wody we krwi
* wiek

## Analiza przyjęć i wypisów

Poniższy wykres pokazuje ilość pacjentów przyjętych i wypisanych danego dnia ze szpitala, z podziałem na wynik leczenia.

```{r, fig.width=10, fig.height=6, out.width="100%", echo=FALSE}
tseries <- df %>% 
  select(1:8) %>% 
  group_by(PATIENT_ID) %>% 
  summarize(across(everything(), last), .groups="drop") %>% 
  select(-RE_DATE, -AGE, -GENDER, -PATIENT_ID) %>%
  pivot_longer(ADMISSION_TIME:DISCHARGE_TIME, names_to="TYPE", values_to="DATE") %>%
  mutate(DATE = floor_date(DATE, "days")) %>%
  mutate(TYPE = str_replace(TYPE, "_TIME", "")) %>% 
  count(TYPE, DATE, OUTCOME) %>%
  rename("COUNT" = "n")

tplot <- ggplot(tseries, aes(x=DATE, y=COUNT, fill=OUTCOME)) + 
  geom_col() + 
  scale_x_datetime(date_breaks = "1 week", date_labels = "%d %b %Y") +
  facet_grid(TYPE ~ .)

ggplotly(tplot)
```

Analiza przyjęć i wypisów nie przynosi żadnych istotnych wniosków. Obserwujemy jedynie zwiększoną ilość wypisów wyleczonych pacjentów między 16 a 20 lutego. Obserwowane luki w czasach przyjęć i wypisów mogą wynikać z podziału zbioru danych na część treningową (analizowaną) i testową (wyłączoną z niniejszej analizy).

### Czas hosptializacji

Poniżesz wykresy prezentują odpowiednio rozkład czasu pobytu pacjentów w szpitalu w zależności od wyników leczenia a także histogram długości pobytu w szpitalu z podziałem na wynik leczenia.

```{r, echo=FALSE, out.width="100%", fig.width=10}
ht <- df %>% select(1:7) %>% select(-RE_DATE) %>% 
  group_by(PATIENT_ID) %>% summarise_all(last) %>% ungroup() %>% 
  mutate(HOSPITALIZATION_TIME = difftime(floor_date(DISCHARGE_TIME, "1 day"), floor_date(ADMISSION_TIME, "1 day"), unit="days"))

ht.boxplot <- ggplot(ht, aes(OUTCOME, as.numeric(HOSPITALIZATION_TIME, unit="days"))) + 
  geom_boxplot() + 
  ylab("HOSPITALIZATION DAYS")

ht.hist <- ggplot(ht, aes(as.numeric(HOSPITALIZATION_TIME, unit="days"), fill=OUTCOME)) + 
  geom_histogram(binwidth = 1) + 
  xlab("HOSPITALIZATION DAYS")

grid.arrange(ht.boxplot, ht.hist, ncol=2, widths=1:2)

```

Obserwujemy, że w grupy pacjentów, którzy zmarli, czas pobytu w szpitalu wynosił do 10 dni (75% przypadków). Tę cechę można potencjalnie wykorzystać przy przygotowaniu klasyfikatora.

Jednocześnie poczyniona obserwacja każe się zastanowić nad dokładnością klasyfikatora zaproponowanego przez autorów [artykułu](https://www.nature.com/articles/s42256-020-0180-7), z którego pochodzą dane. Badacze twierdzą, że dokładność wynosi ponad 90% nawet 10 dni przed poznaniem dokłądnego wyniku leczenia. Z drugiej strony, odrzucenie badań które powstały później, niż 10 dni przed pozniem ostatecznego wyniku, skutkuje odrzuceniem danych o większości zmarłych pacjentów, co pozostawia niezbalansowany zbiór danych. Jak wiadomo dokładność klasyfikatora nie jest odpowiednią do zastosowania metryką przy klasyfikacji niezbalansowanych zbiorów, a wartość miary *Kappa* nie została podana w treści artykułu, co utrudnia ocenienie jakości zaprezentowanego w artykule modelu.

# Klasyfikator

Niniejsza sekcja opisuje proces tworzenia klasyfikatora, którego zadaniem jest ocena, czy dany pacjent przeżył chorobę spowodowaną zakażeniem COVID-19.

Dla tego celu, zbiór wyników badań zostanie zredukowany do danych pacjentów, zawierając ostatni, tj. najbardziej aktualny wynik badania.
Wcześniej, ze zbioru zostaną usunięte te wyniki badań, które zostały uzyskane przed wypisem pacjenta ze szpitala. Dodatkowo usunięte zostanę atrybuty `PATIENT_ID`, `ADMISSION_TIME`, `DISCHARGE_TIME` i `RE_DATE` oraz `2019_nCOV-detection` (ze względu na stałe wartości).

```{r}
patients <- df %>% 
  filter(RE_DATE < DISCHARGE_TIME) %>%
  group_by(PATIENT_ID) %>% 
  fill(everything()) %>% 
  summarise_all(last) %>% 
  ungroup() %>%
  select(-PATIENT_ID, -ADMISSION_TIME, -DISCHARGE_TIME, -RE_DATE) %>%
  select(-'2019_nCov_detection')
```

## Wybór cech

W związku z tym, że dla części pacjentów nie ma dostępnych wszystkich wyników badań, niezbędne jest dalsze przetwarzanie zbioru danych.

Grupa cech "Biochemia krwi" (sekcja **Współwystępowanie kategorii**) została określona jako minimalny zbiór cech, które powinny być obecne w każdym rekordzie. Ten wybór jest uzasadniony tym, że autorzy [artykułu](https://www.nature.com/articles/s42256-020-0180-7) źródłowego wśrod najbardziej znaczących cech wskazali `LDH` i `hs_CRP`, które należą do tej grupy.

Po odrzuceniu rekordów, które nie zawieraływ szystkich wskazanych cech, usunięto kolumny, które zawierały wartości `NA`. W wyniku tego przetwarzania uzyskano czysty zbiór, który może być wykorzystany do trenowania klasyfikatora.

```{r feature selection}
features <- class_labels[[3]]

patients <- patients %>% filter(complete.cases(patients %>% select(all_of(features))))

to.drop <- patients %>% 
  pivot_longer(4:76) %>% 
  mutate(value=is.na(value)) %>% 
  group_by(name) %>% 
  summarize(NAs = sum(value), .groups="drop") %>% 
  filter(NAs != 0)
#to.drop %>% arrange(NAs)

patients <- patients %>% select(-to.drop$name)

all(complete.cases(patients))
```
Ostateczna wersja zbioru zawiera `r nrow(patients)` rekordów pacjentów. Poniższa lista zawier natomiast nazwy wszystkich `r ncol(patients) - 1` cech wykorzystanych do klasyfikacji.

```{r feature-list, echo=FALSE}
features <- colnames(patients)
features[features != "OUTCOME"]
```

Zbalansowanie zbioru prezentuje się następująco

```{r, echo=FALSE}
summary(patients$OUTCOME)
```

W kolejnym kroku zbiór został podzielony na testowy i treningowy, odkładając 25% danych do testowania klasyfikatorów.

```{r train-test split}
set.seed(23)
inTraining <- createDataPartition(
        y = patients$OUTCOME,
        p = .75,
        list = FALSE)

patientsTrain <- patients[ inTraining[,1],]
patientsTest  <- patients[-inTraining[,1],]
```


## Klaysfikatory 

W tej części zostaną wytrenowane i przetestowane dwa klasyfikatory - *Random Forest* i *SVM*.
W trenowaniu zostanie wykorzystana powtarzalna walidacja krzyżowa, z podziałem na 10 części i trzema powtórzeniami.

### Random forest

W modelu *Random Forest* optymlizowany będzie parametr `mtree` określający ilość parametrów, które trafią do drzewa w każdej rundzie podziałów. Jednocześnie ustalono, że wartość parametru określającą ilość drzew w lesie `ntree` będzie wynosiła 30.

```{r}
set.seed(23)
tc <- trainControl(method="repeatedcv", number=10, repeats=3)
rf.grid <- expand.grid(mtry = 5:30)
rf.fit <- train(OUTCOME ~ .,
             data = patientsTrain,
             method = "rf",
             preProc = c("center", "scale"),
             trControl = tc,
             tuneGrid = rf.grid,
             ntree = 30)
rf.fit
```

Wyniki uzyskane w trakcie procesu trenowania charakteryzują się wysoką dokładnością i wartością miary Kappa, co suegeruje że klasyfikator moze dobrze wykonywać swoje zadanie. W kolejnych krokach te wyniki zostaną zweryfikowane na zbiorze testowym.

```{r}
set.seed(23)
rf.predict <- predict(rf.fit, newdata=patientsTest)
confusionMatrix(data = rf.predict, patientsTest$OUTCOME)
```

Klasyfikator pomylił się w 4 przypadkach (na 85) osiągając dokładność na poziomie 95%.

W związkuz  tym, że modeł *Random Forest* jest łatwo interpretowalny, w łatwy sposób można uzyskać ważność cech, która jest przedstawiona w tabeli poniżej.

```{r, message=FALSE, echo=FALSE}
vi <- varImp(rf.fit, scale=FALSE)
knitr::kable(
vi$importance %>% arrange(desc(Overall)) %>% head(5)
)
```

Należy zauważyć, że cechy `LDH` i `hs_CRP`, a także `lymphocyte_percent` są ważnymi czynnikami w wytrenowanym klasyfikatorze, co jest w zgodzie z wnioskami autorów ze źródłowego artykułu.

### SVM

Dla modelu *Support Vector Machine* z kernelem liniowym, optymalizowany jest prametr kosztu.

```{r svm fit}
set.seed(23)
# svmLinear2
svm.grid <- expand.grid(cost = c(.25, .5, .75, 1, 1.25))
svm.fit <- train(OUTCOME ~ .,
             data = patientsTrain,
             method = "svmLinear2",
             preProc = c("center", "scale"),
             trControl = tc,
             tuneGrid = svm.grid
             )
svm.fit
```

Podobnie jak model *Random Forest*, model *SVM* również osiąga wysokie wyniki w klasyfikacji na etapie treningu.

```{r svm predict}
set.seed(23)
svm.predict <- predict(svm.fit, newdata=patientsTest)
confusionMatrix(data = svm.predict, patientsTest$OUTCOME)
```

Na etapie testu model *SVM* popełnił jedynie 3 błędy (ponad 96% dokładności), przez co można go uznać za minimalnie lepszy od modelu *Random Forest*.

# Analiza przeżycia

W tej sekcji wyniki badań pacjentów zostaną poddane analizie metodą regresji Coxa.

Zbiór danych został poddany następującym zmianom:

* usunięto wyniki badań, które mają `RE_DATE` późniejszy niż `DISCHARGE_TIME`
* dodano kolumnę `TIME` która określa liczbę dni, które upłynęły od dokonania badania, do uzyskania rezultatu leczenia (na potrzeby *modelu Coxa*)
* zakodowano zmienne kategoryczne `OUTCOME` i `GENDER` jako wartości numeryczne
* usunięto zbędne dla analizy kolumny `PATIENT_ID`, `ADMISSION_TIME`, `DISCHARGE_TIME`, `RE_DATE` oraz kolumnę `2019_nCov_detection` ze względu na identyczne wartości

```{r cox data transform, echo=FALSE}
cox.df <- df %>%
  filter(RE_DATE < DISCHARGE_TIME) %>%
  mutate(TIME = as.numeric(difftime(floor_date(DISCHARGE_TIME, "1 day"), floor_date(RE_DATE, "1 day"), unit="days"), unit="days")) %>%
  mutate(GENDER = as.numeric(GENDER)) %>% 
  mutate(OUTCOME = as.numeric(OUTCOME)) %>% 
  select(-PATIENT_ID, -ADMISSION_TIME, -DISCHARGE_TIME, -RE_DATE) %>%
  select(-'2019_nCov_detection')
```

W kolejnych krokach dla każdego z atrybutów (niezależnie) wykonano analizę tzw. *Hazard Ratio (HR)* przy pomocy *modelu proporcjonalnego hazardu Coxa*. 
*Hazard Ratio* jest wyjaśnione następująco [źródło](http://www.sthda.com/english/wiki/cox-proportional-hazards-model):

> Put another way, a hazard ratio above 1 indicates a covariate that is positively associated with the event probability, and thus negatively associated with the length of survival.

```{r, echo=FALSE}
# source: http://www.sthda.com/english/wiki/cox-proportional-hazards-model
set.seed(23)
covariates <- colnames(cox.df)
covariates <- covariates[covariates %!in% c("TIME", "OUTCOME")]
univ_formulas <- sapply(covariates,
                        function(x) as.formula(paste('Surv(TIME, OUTCOME)~', x)))
                        
univ_models <- lapply( univ_formulas, function(x){coxph(x, data = cox.df)})
# Extract data 
univ_results <- lapply(univ_models,
                       function(x){ 
                          x <- summary(x)
                          p.value<-x$wald["pvalue"]
                          wald.test<-x$wald["test"]
                          beta<-signif(x$coef[1], 4) # coefficient beta
                          HR <-signif(x$coef[2], digits=4); #exp(beta)
                          HR.confint.lower <- signif(x$conf.int[,"lower .95"], 2)
                          HR.confint.upper <- signif(x$conf.int[,"upper .95"], 2)
                          #HR <- paste0(HR, " (", HR.confint.lower, "-", HR.confint.upper, ")")
                          res<-c(beta, HR, wald.test, p.value)
                          names(res)<-c("beta", "HR", "wald.test", "p.value")
                          return(res)
                         })
res <- t(as.data.frame(univ_results, check.names = FALSE))
res <- as.data.frame(res)
res <- res %>% filter(p.value < .05) %>% arrange(desc(HR))
```

Poniższa tabela prezentuje czynniki zwiększające ryzyko śmierci pacjenta. Odfiltrowane zostały czynniki nieistotne statysytcznie (*p-wartość > 0.05*) oraz te, gdzie parametr *HR* nie przekroczył wartości *1.1*.

```{r, echo=FALSE}
knitr::kable(
  res %>% filter(HR > 1.1)
)
```

Parametrem, który w największym stopniu zwiększa ryzyko śmierci, według przygotowanego modelu jest `basophil_count`. Jednocześnie uzskany wynik zdaje się być wątpliwy, gdyż `basophil_count` ma wartość parametru *HR* o sześć rzędów wielkości większą, niż kolejny parametr w rankingu.

Pozostałe złe prognostyki, dotyczą między innymi zwiększonej obecności neutrofilów, krzepliwości krwi (wyskoie `INR`) a także jakość komórek krwi (`MPV`, `RCDW`, `PDW`).
 
Poniższa tabela przedstawia dobre prognostyki jeśli chodzi o skutki leczenia. Ponownie odlitrowano czynniki nieistotne statystycznie (*p-wartość > 0.05*), oraz pozostawion wartości, gdzie parametr *HR* ma wartość poniżej *0.9*.

```{r, echo=FALSE}
knitr::kable(
  res %>% filter(HR < 0.9)
)
```
 
Do pozytywnych prognostyków można zaliczyć:

* większy poziom albumin
* większą proporcję monocytów, leukocytów i eozynofilów we krwi
* płeć - kobiety mają większą szansę przeżycia
* większy cholesterol


Wśród czynników obniżających wpółczynnik ryzyka, znajduje się też `basophil_percent` co wydaje się być szczególnie intrygujące w kontekście wykrytych negatywnych prognostyków.

Wśród wykrytych pozytywnych prognostyków, 3 ostatnie wydają się mieć bardzo istotny wpływ na obniżenie ryzyka śmierci pacjenta.


# Techniczne

Ninejsza sekcja zawiera dodatkowe informacje o technicznych parametrach raportu

## Wszytkie użyte pakiety

```{r}
unique(c(.packages(), loadedNamespaces()))
```
